[dialog5("Character Sheet", "width=800; height=800; temporary=0; input=1; noframe=0"), code: {
	<head>
		
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
		<link rel="stylesheet" type="text/css" href="style.css@lib:front"></link>
		[r:scriptTag("open")][r:importScript("images.js@lib:front")][r:scriptTag("close")]
		[r:scriptTag("open")][r:importScript("script.js@lib:front")][r:scriptTag("close")]
		[r:scriptTag("open")][r:importScript("components_new.js@lib:front")][r:scriptTag("close")]
		[r:'
	
		<style>
			#level-div {
				position: absolute; 
				right: 0;  
				bottom: 0; 
				margin: 0; 
				font-size: 130%;
				background-color: #292929;
				border: 0.2vh solid #555;
				border-radius: 100%;
				height: 4.5vh;
				width: 4.5vh;
			}
			#level-div > span {
				position: relative;
				color: #ddd;
				top: 25%;
				font-weight: bold;
			}

			#level-div.level-up {
				cursor: pointer;
			}

			#level-div.level-up:hover {
				background-color: #666;
				cursor: pointer;
			}

			#character-tab-left {
				position:absolute;
				width:33%;
				height:98%;
				left:0;
				top:1%;
	
				overflow-y:inherit
			}
			#character-tab-center {
				position:absolute;
				left: 33%;
				width:34%;
				height:100.5%;
				bottom: -0.5vh;
	
				background-color:#2d2d2d; 
				border: 0.2vh solid #444;
				border-bottom: none;
	
				overflow-y:inherit;
			}
			#character-tab-right {
				position:absolute;
				width:33%;
				height:98%;
				right:0;
				top:1%;
	
				overflow-y:inherit;
			}

			#character-tab-right .container {
				padding-top: 2vh;
				padding-right: 0;
				padding-left: 0;
				padding-bottom: 0;

				width:85%;
			}

			#portrait {
				height:15vh; 
				border-radius: 50%; 
				border: 0.3vh solid #444;
			}

			hr {
				border: 0.1vh solid #444;
				display:block;
				width: 100%;
				margin:auto;
				margin-top: 2vh;
				margin-bottom: 0;
			}

			#character-tab-right .table-header {
				margin-bottom: -1.5vh;
			}
			#character-tab-left .container {
				padding-top:0vh;
				padding-bottom: 2vh;
			}

			#ability-scores-container-content > .table-container {
				margin-right:-1.5vh;
				margin-left:-1.5vh;
				
			}

			.item-selected {
				background-color: #3a3a3a;
			}

			.tooltip.tooltip-bottom::after {
				top: 120%;
			}

			/*=====================================================================================================*/
			/* XP bar */
			/*=====================================================================================================*/

			.exp-bar {
				position: relative;
				width: 17vh;
				height: 17vh;
				margin: -0.5vh 0px;
		
				background: rgba(0,0,0,0.15);
				border-radius: 50%;
				border: 0.2vh solid #444;
		
				display: flex;
				justify-content: center;
				align-items: center;
			}
		</style>
	
		<script>

			//=====================================================================================================
			// Helper functions
			//=====================================================================================================

			function warning({parent, text}) {
				modal({parent: parent, children: [
					{tag: "p", style: {textAlign: "center", fontWeight: "bold", fontSize: "110%", marginTop: "0.5vh"}, text: "Warning"},
					{tag: "p", text: text},
					{tag: "button", text: "Close", events:{click: close_modal}}
				]})
			}
			function title_value({title, value}) {
				return {tag: "p", style: {margin: "0.3vh 0", padding: "0"}, children: [
					{tag: "span", style: {fontWeight: "bold"}, text: title + ": "},
					{tag: "span", style: {color: "#aaa"}, text: value},
				]}
			}
			function updateEXPBar(percent) {
				function crunchNumber(num, from = [0, 100], to = [0, 100]) {
					// Define the input and output ranges
					const inputMin = from[0];
					const inputMax = from[1];
					const outputMin = to[0];
					const outputMax = to[1];
					
					// Calculate the proportion and map to new range
					const proportion = (num - inputMin) / (inputMax - inputMin);
					const crunched = outputMin + proportion * (outputMax - outputMin);
					
					return crunched;
				}
				// Crunching
				const from = [0, 100]
				const to = [0, 100]

				const start_percent = crunchNumber(percent, from, to)
				const end_percent = crunchNumber(percent == 0 ? 0 : percent + 1, from, to)
				const color = percent >= 100 ? "#ddd" : "#782f78"

				getId("experience").style.background = `linear-gradient(0deg, ` + color + ` ` + start_percent + `%, rgba(0,0,0,0.15) ` + end_percent + `%)`
			}
			function bonusOf(number, parenthesis=false) {
				number = Number(number) > 0 ? "+"+number : number
				number = parenthesis ? "("+number+")" : number

				return String(number)
			}
			function capitalizeAll(str) {
				return str
					.split(" ")
					.map(word => word.charAt(0).toUpperCase() + word.slice(1))
					.join(" ");
			}
			function subtitle({text}) {
				return {tag: "p", text, style: {opacity: "0.8", fontWeight: "bold", fontSize: "110%", marginBottom:"-1.5vh"}}
			}
			function ability_scores() {
					function gridItem(text, id="") {
						return {tag: "div",
							style: {
								fontWeight: "bold",
								textAlign: "center"
							},
							attributes: {id},
							text
						}
					}

					return element(
						{tag: "div",
							style: {
								display: "grid",
								marginTop: "1vh",
								gridTemplateColumns: "repeat(6, 1fr)",
								gridTemplateRows: "repeat(2, auto)",
							},
							children: [
								gridItem("STR"),
								gridItem("DEX"),
								gridItem("CON"),
								gridItem("WIS"),
								gridItem("INT"),
								gridItem("CHA"),

								gridItem("0", "strength"),
								gridItem("0", "dexterity"),
								gridItem("0", "constitution"),
								gridItem("0", "wisdom"),
								gridItem("0", "intelligence"),
								gridItem("0", "charisma"),
							]
						}
					)
				}
			function isEqualJSON(a, b) {
				return JSON.stringify(a) === JSON.stringify(b)
			}
			async function closeIfNotImpersonated () {
				if (await backend("impersonated()") == "") {closePage("Character Sheet")}
			}

			//=====================================================================================================
			// Item Dragging
			//=====================================================================================================
						
			let draggedElement = null, initialPosition = null
			function dragstart(event) {
				draggedElement = event.target;
				draggedElement.parentNode.parentNode.parentNode.classList.remove("item-tooltip-container")
				initialPosition = draggedElement.getAttribute("position");
			}
			function dragend(event) {
				draggedElement.style.visibility = "visible";
				draggedElement.parentNode.parentNode.parentNode.classList.add("item-tooltip-container")
			}
			function dragover(event) {
				event.preventDefault();
			}
			function drop(event) {
				event.preventDefault();
				const target = event.target.closest(".inventory-slot");

				if (target) {
					const finalPosition = target.getAttribute("position");

					let request = ` impersonated().move_item(`
					request += !isNaN(Number(initialPosition)) ? initialPosition : `"`+initialPosition+`"`
					request += `, `
					request += !isNaN(Number(finalPosition)) ? finalPosition : `"`+finalPosition+`"`
					request += `)`
					//` impersonated().move_item("`+initialPosition+`", "`+finalPosition+`") `

					toBackend(request)
					updateInventoryTab()

					// Reset draggedElement visibility without moving it
					draggedElement.style.visibility = "hidden";
				}
			}
			
			//=====================================================================================================
			// Modals and context menus
			//=====================================================================================================

			function itemContext(event, slot, position) {
				if (event.button != 2) return;

				// Define context-menu buttons
				const buttons = {
					"Description": () => {itemDescription(slot)},
					"Unequip": () => {itemUnequip(position)},
					"Split": () => {itemSplit(slot, position)},
					"Send to Target": () => {backend(`impersonated().send_item("`+position+`")`)},
					"Drop": () => {itemDrop(slot, position)},
				}

				// Remove invalid options
				if (!isNaN(Number(position))) delete buttons["Unequip"]
				if (slot.amount == 1) delete buttons["Split"]
				
				context_menu({event: event, buttons: buttons})
			};
			async function itemDescription(slot) {
				// Item from database
				const item = JSON.parse(await backend(`database.get_item("` + slot.name + `")`)) || {}

				// Name
				const name = slot.amount == 1
					? item.name
					: slot.amount + " " + item.name + "s"

				// Subtitle
				const type = item.subtype || item.type
				const rarity = item.rarity == "common"
					? ""
					: item.rarity + " "
				const subtitle = capitalizeAll(rarity + type)

				// Weight
				const weight = Math.round(item.weight * slot.amount * 100) / 100 + "lb"

				// Damage
				let damage = ""
				for (let i = 0 ; i < item.damage.length ; i++) {
					const current = item.damage[i]
					damage += current["die_ammount"] + "d" + current["die_size"] + " " + current["damage_type"].toLowerCase()
					damage += i != item.damage.length - 1 ? ", " : "" // -> adds comma if it is not the last element
				}

				// Other Arrays
				const properties = item.properties.length > 0 != "" ? capitalize(item.properties.join(", ")) : ""
				const conditions = item.conditions.length > 0 != "" ? capitalize(item.conditions.join(", ")) : ""

				// Element
				function title_value({title, value}) {
					return {tag: "p", style: {margin: "0.3vh", padding: "0"}, children: [
						{tag: "span", style: {fontWeight: "bold"}, text: title + ": "},
						{tag: "span", style: {color: "#aaa"}, text: value},
					]}
				}

				modal({parent: document.getElementById("inventory-tab"), children: [
					{tag: "div", style: {padding: "0 1vh"}, children: [
						{tag: "div", 
							style: {textAlign: "center", margin: "1vh", padding: 0, position: "relative", margin: "auto", marginBottom: "2vh", width: "fit-content"}, 
							children: [
								{tag: "span", style: {fontWeight: "bold", fontSize: "110%"}, text: name},
								{tag: "br"},
								{tag: "span", style: {color: "#aaa"}, text: subtitle},
								{tag: "img", attributes: {src: item.image}, style: {position: "absolute", left: "-5.5vh", top: 0, height: "4vh"}}
							]
						},
						{tag: "div", style: {textAlign: "left"}, children: [
							damage ? title_value({title: "Damage", value: damage}) : null,
							item.recovery ? title_value({title: "Recovery Speed", value: String(item.recovery)}) : null,
							item.base_armor_class ? title_value({title: "Armor Class", value: item.base_armor_class}) : null,
							weight ? title_value({title: "Weight", value: weight}) : null,
							properties ? title_value({title: "Properties", value: properties}) : null,
							conditions ? title_value({title: "Conditions", value: conditions}) : null,
						]},
						item.description ? {tag: "pre", style: {color: "#aaa", textAlign: "left"}, text: item.description} : null
					]}
				]})
			}
			async function itemUnequip(position) {
				backend(`impersonated().split_item("`+position+`")`)
			}
			async function itemSplit(slot, position) {
				// Item from database
				const item = JSON.parse(await backend(`database.get_item("` + slot.name + `")`)) || {}

				modal({parent: document.getElementById("inventory-tab"), children: [
					// Collect split amount
					input({id: "modal-split-amount", placeholder: "Ammount to split", options: {div: {style: {width: "70%"}}}}), 
					
					// Spacing
					{tag: "div", style: {height: "1vh"}},

					// Uses drop amount inserted on input field for drop function
					{tag: "button", text: "Split", events: {click: () => {
						const split_amount = document.getElementById("modal-split-amount").value

						backend(`impersonated().split_item("`+position+`", `+split_amount+`)`)
						close_modal()
					}}}
				]})

				// Set value for the input field
				const split_amount = document.getElementById("modal-split-amount")
				split_amount.value = Math.floor(slot.amount / 2)
				split_amount.dispatchEvent(new Event("input"))
			}
			async function itemDrop(slot, position) {
				// If single item in slot automatically drops
				if (slot.amount == 1) {
					backend(`impersonated().drop_item("`+position+`")`)
					return
				}

				// Create modal to ask how many to drop
				modal({parent: document.getElementById("inventory-tab"), children: [
					// Collect drop amount
					input({id: "modal-drop-amount", placeholder: "Ammount to drop", options: {div: {style: {width: "70%"}}}}), 
					
					// Spacing
					{tag: "div", style: {height: "1vh"}},

					// Uses drop amount inserted on input field for drop function
					{tag: "button", text: "Drop", events: {click: () => {
						const drop_amount = document.getElementById("modal-drop-amount").value

						backend(`impersonated().drop_item("`+position+`", `+drop_amount+`)`)
						close_modal()
					}}}
				]})

				// Set value for the input field
				const drop_amount = document.getElementById("modal-drop-amount")
				drop_amount.value = slot.amount
				drop_amount.dispatchEvent(new Event("input"))
			}


			//=====================================================================================================
			// Update Page
			//=====================================================================================================

			let character_tab = {
				basic: {}, info: {}, skills: {}, saving_throws: {}, 
				conditions: {}, features: {}, proficiencies: {}, resistances: {}
			}
			async function updateCharacterTab() {
				// Character
				const character = JSON.parse(await backend(`JSON.stringify(
					{
						basic: {
							name: impersonated().name,
							portrait: impersonated().portrait,
							level: impersonated().level,
							experience: impersonated().experience,
							level_up_experience: impersonated().level_up_experience || 0,
							classes: impersonated().classes,
							ability_scores: impersonated().ability_scores,
						},
						info: {
							"Type": impersonated().type,
							"Race": impersonated().race,
							" ":" ",
							"Health": impersonated().health + " / " + impersonated().max_health,
							"Armor Class": impersonated().armor_class,
							"Initiative": 0,
							"Passive Perception": 10,
							"Speed": impersonated().speed + "ft",
						},
						skills: impersonated().skills,
						saving_throws: impersonated().saving_throws,
						conditions: impersonated().conditions,
						features: impersonated().features,
						proficiencies: impersonated().proficiencies,
						resistances: impersonated().resistances
					}
				)`))

				// Cancel execution if there is no update to character
				if (isEqualJSON(character_tab, character)) { return }

				// Database
				const database = JSON.parse(await backend(`JSON.stringify(
					{
						conditions: database.conditions.data,
						features: database.features.data,
						proficiencies: database.proficiencies.data, proficiencies_ordered: database.get_proficiencies_list(),
						damage_types: database.damage_types.data
					}
				)`))

				// Update name, portrait, class, and ability scores
				function updateBasicAttributes () {
					if (!isEqualJSON(character_tab.basic, character.basic)) {
						character_tab.basic = character.basic
						const experiencePercent = (character.basic.experience / character.basic.level_up_experience) * 100

						document.getElementById("name").textContent = character.basic.name
						document.getElementById("portrait").setAttribute("src", character.basic.portrait)

						// Level and Experience bar
						const level_div = document.getElementById("level-div")
						level_div.clearChildren()
						updateEXPBar(experiencePercent)
						if(character.basic.experience >= character.basic.level_up_experience) {
							level_div.classList.add("level-up")
							level_div.setAttribute("tooltip", "Click here to level up!")
							level_div.appendChild({tag:"img", 
								attributes: {src: "asset://5282add24bd7663d499861e313980245"}, 
								style: {height: "1.5em", marginTop: "0.7vh", cursor: "pointer"},
								events: {click: () => openPage("character_level_up.html", "")}
							})
						}
						else {
							level_div.classList.remove("level-up")
							level_div.setAttribute("tooltip", character.basic.experience + " / " + character.basic.level_up_experience + " XP")
							level_div.appendChild({tag:"span", text: String(character.basic.level)})
						}

						// Classes text
						let class_text = ""
						for (const cls in character.basic.classes) {
							class_text += class_text ? " / " : ""
							class_text += capitalize(cls)
						}
						document.getElementById("class").textContent = class_text || "None"

						// Ability Scores
						for (const score in character.basic.ability_scores) {
							document.getElementById(score).textContent = character.basic.ability_scores[score]
						}
					}
				}
				updateBasicAttributes ()

				// Update info area
				function updateInfo () {
					if (!isEqualJSON(character_tab.info, character.info)) {
						character_tab.info = character.info

						// Clear Skills
						const info_container = document.getElementById("info")
						info_container.clearChildren()

						// Append Skills with bonuses
						for (const title in character.info) {
							const value = character.info[title] + ""
							info_container.appendChild(
								{tag:"div", style: {height: "2vh", marginBottom: "1vh", position: "relative"}, children: [
									{tag: "p", style: {position: "absolute", left: "1vh", textAlign: "left", fontWeight: "bold"}, text: title},
									{tag: "p", style: {position: "absolute", right: "1vh", textAlign: "left"}, text: value}
								]}
							)
						}
					}
				}
				updateInfo ()

				// Update skills
				function updateSkills () {
					if (!isEqualJSON(character_tab.skills, character.skills)) {
						character_tab.skills = character.skills

						// Clear Skills
						const skills_container = document.getElementById("skills")
						skills_container.clearChildren()

						// Append Skills with bonuses
						for (const skill in character.skills) {
							const title = capitalize(skill)
							const value = bonusOf(character.skills[skill])
							skills_container.appendChild(
								{tag:"div", style: {height: "2vh", marginBottom: "1vh", position: "relative"}, children: [
									{tag: "p", style: {position: "absolute", left: "1vh", textAlign: "left", fontWeight: "bold"}, text: title},
									{tag: "p", style: {position: "absolute", right: "1vh", textAlign: "left"}, text: value}
								]}
							)
						}
					}
				}
				updateSkills()

				// Update saving throws
				function updateSavingThrows () {
					if (!isEqualJSON(character_tab.saving_throws, character.saving_throws)) {
						character_tab.saving_throws = character.saving_throws

						// Clear Saving Throws
						const saving_throws_container = document.getElementById("saving-throws")
						saving_throws_container.clearChildren()

						// Append Saving Throws with bonuses
						for (const score of ["strength", "dexterity", "constitution", "wisdom", "intelligence", "charisma"]) {
							const title = capitalize(score)
							const value = bonusOf(character.saving_throws[score])
							saving_throws_container.appendChild(
								{tag:"div", style: {height: "2vh", marginBottom: "1vh", position: "relative"}, children: [
									{tag: "p", style: {position: "absolute", left: "1vh", textAlign: "left", fontWeight: "bold"}, text: title},
									{tag: "p", style: {position: "absolute", right: "1vh", textAlign: "left"}, text: value}
								]}
							)
						}
					}
				}
				updateSavingThrows()

				// Update conditions
				function updateConditions () {
					if (!isEqualJSON(character_tab.conditions, character.conditions)) {
						character_tab.conditions = character.conditions

						// Clear conditions
						const conditions = document.getElementById("character-conditions")
						conditions.clearChildren()

						// Append Conditions
						for (const name in character.conditions) {
							// From character
							const duration = timeUnit(character.conditions[name])

							// From database
							const condition = database.conditions[name]
							const description = condition.description || "Description unavailable"
							const image = condition_images[condition.type] || ""

							// Element
							collapsible(
								{parent: conditions,
									options: {
										button: {style: {display: "flex", gap: "1vh", padding: "0.5vh", margin: "0 1vh"}},
										content: {style: {marginRight: "1.3vh", marginLeft: "1.3vh"}}
									},
									button_children: [
										{tag: "img", attributes: {src: image}},
										{tag: "span", text: name},
										{tag: "span", style: {position: "absolute", right: "1vh"}, text: duration}
									],
									children: [
										{tag: "pre", style: {fontSize: "90%"}, text: description}
									]
								}
							)
						}

						// Hide container if empty
						if (conditions.children.length == 0) { 
							conditions.parentElement.classList.add("hidden") 
						} 
						else { 
							conditions.parentElement.classList.remove("hidden") 
						}
					}
				}
				updateConditions()

				// Update features
				function updateFeatures () {
					if (!isEqualJSON(character_tab.features, character.features)) {
						character_tab.features = character.features

						// Clear container
						const features = document.getElementById("character-features")
						features.clearChildren()

						// Append features
						for (const name of character.features) {
							// From database
							const feature = database.features[name]
							const type = feature.subtype || feature.type || "None"
							const image = class_images[type] || feature_images[type] || ""
							const description = feature.description || "Description unavailable"

							// Element
							collapsible(
								{parent: features,
									options: {
										button: {style: {display: "flex", gap: "1vh", padding: "0.5vh", margin: "0 1vh"}},
										content: {style: {marginRight: "1.3vh", marginLeft: "1.3vh"}}
									},
									button_children: [
										{tag: "img", attributes: {src: image}},
										{tag: "span", text: name}
									],
									children: [
										{tag: "pre", style: {fontSize: "90%"}, text: description}
									]
								}
							)
						}

						// Hide container if empty
						if (features.children.length == 0) { 
							features.parentElement.classList.add("hidden") 
						} 
						else { 
							features.parentElement.classList.remove("hidden") 
						}
					}
				}
				updateFeatures()

				// Update features
				function updateProficiencies () {
					if (!isEqualJSON(character_tab.proficiencies, character.proficiencies)) {
						character_tab.proficiencies = character.proficiencies

						// Ordered proficiencies
						const character_proficiencies_ordered = database.proficiencies_ordered.filter(
							item => Object.keys(character.proficiencies).includes(item)
						)

						// Clear container
						const proficiencies = document.getElementById("character-proficiencies")
						proficiencies.clearChildren()

						// Append Conditions
						for (const name of character_proficiencies_ordered) {
							// From character
							const level = Number(character.proficiencies[name])

							// From database
							const proficiency = database.proficiencies[name]
							if (!proficiency) { continue }
							
							const type = proficiency.type || "None"
							const description = proficiency.description.slice(0, level + 1) || ""
							const image = proficiency_images[type] || ""
							const level_title = " " + ["", "Expertise", "Mastery", "Grandmastery"][level]

							// Skip certain types
							if (["skill"].includes(type)) {continue}

							// Create description
							const children = []
							for (const text of description) {
								children.push(
									{tag: "pre", style: {fontSize: "90%"}, text}
								)
							}

							// Element
							collapsible(
								{parent: proficiencies,
									options: {
										button: {style: {display: "flex", gap: "1vh", padding: "0.5vh", margin: "0 1vh"}},
										content: {style: {marginRight: "1.3vh", marginLeft: "1.3vh"}}
									},
									button_children: [
										{tag: "img", attributes: {src: image}},
										{tag: "span", text: name + (type == "language" ? "" : level_title)}
									],
									children
								}
							)

							// Hide container if empty
							if (proficiencies.children.length == 0) { 
								proficiencies.parentElement.classList.add("hidden") 
							} 
							else { 
								proficiencies.parentElement.classList.remove("hidden") 
							}
						}
					}
				}
				updateProficiencies()

				// Update resistances
				function updateResistances () {
					// Update
					if (!isEqualJSON(character_tab.resistances, character.resistances)) {
						character_tab.resistances = character.resistances

						// Clear container
						const resistances = document.getElementById("character-resistances")
						resistances.clearChildren()

						// Append Conditions
						for (const name in character.resistances) {
							// From character
							const {type, reduction} = character.resistances[name]

							// Skip if resistance has default values
							if (type == "default" && reduction == 0) {continue}

							// From database
							const damage_type = database.damage_types[name]
							const image = damage_type.image
							const description = damage_type.description

							// Resistance value shown
							const resistance = type != "default" ? capitalize(type) : reduction

							// Element
							collapsible(
								{parent: resistances,
									options: {
										button: {style: {display: "flex", gap: "1vh", padding: "0.5vh", margin: "0 1vh"}},
										content: {style: {marginRight: "1.3vh", marginLeft: "1.3vh"}}
									},
									button_children: [
										{tag: "img", attributes: {src: image}},
										{tag: "span", text: name},
										{tag: "span", style: {position: "absolute", right: "1vh"}, text: String(resistance)}
									],
									children: [
										{tag: "pre", style: {fontSize: "90%"}, text: description}
									]
								}
							)
						}

						// Hide container if empty
						if (resistances.children.length == 0) { 
							resistances.parentElement.classList.add("hidden") 
						} 
						else { 
							resistances.parentElement.classList.remove("hidden") 
						}
					}
				}
				updateResistances()
			}

			let inventory_tab = {
				basic: {},
				equipment: {},
				inventory: []
			}
			async function updateInventoryTab() {
				// Character Items
				const character = JSON.parse(await backend(`JSON.stringify(
					{
						basic: {
							armor_class: impersonated().armor_class
						},
						equipment: impersonated().equipment,
						inventory: impersonated().inventory
					}
				)`))

				// Cancel execution if there is no update to character
				if (isEqualJSON(inventory_tab, character)) { return }

				// Database
				const database = JSON.parse(await backend(`database.items.data`))

				// Basic Attributes
				function updateBasicAttributes() {
					// Verify if basic properties received changes
					if (isEqualJSON(inventory_tab.basic, character.basic)) { return }
					inventory_tab.basic = character.basic

					// Armor Class
					document.getElementById("armor-class").textContent = character.basic.armor_class
				}
				updateBasicAttributes()

				// Equipment
				function updateEquipment() {
					// Verify if equipment received changes
					if (isEqualJSON(inventory_tab.inventory, character.inventory) && isEqualJSON(inventory_tab.equipment, character.equipment)) { return }
					inventory_tab.equipment = character.equipment

					// Clear Equipment
					const equipment = document.getElementById("equipment")
					equipment.clearChildren()

					// Create slots
					const equipment_slot_positions = [
						"", "amulet", "head", "ammunition", "",
						"","hands", "body", "cape", "",
						"","left ring","belt","right ring", "",
						"","","feet","","",
						"","","","","",
						"primary main hand", "primary off hand", "", "secondary main hand", "secondary off hand",
					]
					for (const position of equipment_slot_positions) {
						// Defining slot from equipment, item from database
						const slot = character.equipment[position]
						const item = slot ? database[slot.name] : null
						
						// Offhand ~ Mainhand slot verification
						let isTwoHanded = false, two_hand_image
						if (position.includes("off hand")) {
							// Gathering main hand information
							const main_hand_position = position.includes("primary") ? "primary main hand" : "secondary main hand"
							const slot = character.equipment[main_hand_position]
							const item = slot ? database[slot.name] : null

							// Updates variables based on main hand information
							if (item) {
								isTwoHanded = item.properties.includes("Two-handed")
								two_hand_image = item.image
							}
						}

						// Item element creation
						let image = null, amount = null
						if (item) { // --> Slot contains item
							// Tooltip
							const name = slot.amount > 1 ? slot.amount + " " + item.name + "s" : item.name
							const weight = " (" + Math.round(item.weight * slot.amount * 100) / 100 + "lb)"
							const tooltip = name + " " + weight

							// Item amount (when slot amount > 1)
							amount = slot.amount > 1
								? {tag: "span", attributes: {class: "inventory-item-amount"}, style: {pointerEvents: "none"}, text: String(slot.amount)}
								: null

							// Item image
							image = 
							 {tag: "span", attributes: {class: "tooltip tooltip-bottom", tooltip: tooltip}, children: [
								{tag: "img",
									attributes: {
										src: item.image,
										draggable: "true",
										class: "inventory-item",
										position: position,
									},
									events: {
										dragstart, 
										dragend, 
										mousedown: (event)=> itemContext(event, slot, position),
									}
								}
							]}
						} 
						else if (isTwoHanded) { // --> No item on slot but two-handed weapon
							image = 
								{tag: "img",
									attributes: {
										src: two_hand_image,
										class: "inventory-item",
										position: position
									},
									style: {opacity: "0.2", cursor: "default"}
								}
						}
						else { // --> Empty slot, receives placeholder image
							image = 
								{tag: "img",
									style: {
										filter: "brightness(100)",
										opacity: "0.05",
										position: "relative",
										height: "85%",
										top: "7.5%",

										// Prevent dragging of placeholder image
										userSelect: "none",
										pointerEvents: "none"
									},
									attributes: {src: equipment_images[position]},
								}
						}

						// Slot
						if (position) {
							// Reduce opacity on secondary weapon set
							const style = position.includes("secondary") ? {opacity: "0.5", borderColor: "#333"} : {}

							// Element
							equipment.appendChild(
								{tag: "div", 
									attributes: {
										class: "inventory-slot item-tooltip-trigger",
										position: position
									},
									style: style,
									events: {dragover, drop},
									children: [image, amount]
								}
							)
						}
						else {equipment.appendChild({tag: "div"})} // --> add empty div to fill grid
					}
				}
				updateEquipment()

				// Inventory
				function updateInventory() {
					// Verify if inventory received changes
					if (isEqualJSON(inventory_tab.inventory, character.inventory) && isEqualJSON(inventory_tab.equipment, character.equipment)) { return }
					inventory_tab.inventory = character.inventory

					// Clear Equipment
					const inventory = document.getElementById("inventory")
					inventory.clearChildren()

					// Create slots
					for (let position = 0 ; position < character.inventory.length ; position++) {
						// Defining slot from equipment, item from database
						const slot = character.inventory[position]
						const item = slot ? database[slot.name] : null

						// Item element creation
						let image = null, amount = null
						if (item) { // --> Slot contains item
							// Tooltip
							const name = slot.amount > 1 ? slot.amount + " " + item.name + "s" : item.name
							const weight = " (" + Math.round(item.weight * slot.amount * 100) / 100 + "lb)"
							const tooltip = name + " " + weight

							// Item amount (when slot amount > 1)
							amount = slot.amount > 1
								? {tag: "span", attributes: {class: "inventory-item-amount"}, style: {pointerEvents: "none"}, text: String(slot.amount)}
								: null

							// Item image
							image = 
							 {tag: "span", attributes: {class: "tooltip tooltip-bottom", tooltip: tooltip}, children: [
								{tag: "img",
									attributes: {
										src: item.image,
										draggable: "true",
										class: "inventory-item",
										position: position,
									},
									events: {
										dragstart, 
										dragend, 
										mousedown: (event)=> itemContext(event, slot, position)
									}
								}
							]} 
						}

						// Element
						inventory.appendChild(
							{tag: "div", 
								attributes: {
									class: "inventory-slot item-tooltip-trigger",
									position: position
								},
								events: {dragover, drop},
								children: [image, amount]
							}
						)
					}
				}
				updateInventory()
			}

			let abilities_tab = {
				classes: {},
				spells: {}
			}
			async function updateAbilitiesTab() {
				// Helpers
				function getMainClass(classObj) {
					let highestLevel = -Infinity;
					let highestClass = null;

					for (const [className, classInfo] of Object.entries(classObj)) {
						if (classInfo.level > highestLevel) {
						highestLevel = classInfo.level;
						highestClass = className;
						}
					}

					return highestClass;
				}
				function spellDescription(spell) {
					// Show description
					modal({parent: document.getElementById("abilities-tab"), children: [
						{tag: "div", style: {padding: "0 1vh"}, children: [
							// Title
							{tag: "div", style: {marginTop: "0.5vh", marginBottom: "2vh"}, children: [
								{tag: "div", style: {fontSize: "120%", fontWeight: "bold", margin: 0}, text: spell.name},
								{tag: "div", style: {color: "#aaa", margin: 0, marginBottom: "1vh"}, text: capitalize(spell.school) + " Spell"},
							]},
							// Attributes
							{tag: "div", style: {textAlign: "left"}, children: [
								spell.classes && title_value({title: "Classes", value: capitalize(spell.classes.join(", "))}),
								spell.components && title_value({title: "Components", value: capitalize(spell.components.join(", "))}),
								spell.target && title_value({title: "Target", value: capitalize(spell.target)}),
								spell.range && title_value({title: "Range", value: capitalize(spell.range)}),
								spell.cast_time && title_value({title: "Casting Time", value: capitalize(spell.cast_time)}),
								spell.duration && title_value({title: "Duration", value: capitalize(spell.duration)}),
							]},
							// Description
							spell.description 
								&& {tag: "pre", style: {color: "#aaa", textAlign: "left", padding: 0, margin: 0, marginTop: "1vh"}, text: spell.description},
							spell.description_higher_levels 
								&& {tag: "pre", style: {color: "#aaa", textAlign: "left", padding: 0, margin: 0, marginTop: "1vh"}, children: [
									{tag: "b", style: {color: "#ddd"}, text: "At Higher Levels: "},
									{tag: "span", text: spell.description_higher_levels}
								]},
						]}
					]})
				}

				// Character Abilities
				const character = JSON.parse(await backend(`JSON.stringify(
					{
						classes: impersonated().classes || {},
						spells: impersonated().spells || {},
					}
				)`))

				// Cancel execution if there is no update to character
				if (isEqualJSON(abilities_tab, character)) return
				else abilities_tab.classes = character.classes

				// Database
				const { database, spells_list } = JSON.parse(await backend(`JSON.stringify({
					database: database.spells.data,
					spells_list: database.get_spells_list()
				})`))

				// Update Spells
				async function updateSpells() {
					abilities_tab.spells = character.spells

					// Get main class
					const main_class = getMainClass(character.classes)
					const spellcasting = JSON.parse(await backend(main_class + `?.spellcasting || {}`))

					// Clear container
					const abilities_container = document.getElementById("abilities-tab-abilities")
					abilities_container.clearChildren()
					if (isEqualJSON(spellcasting, {})) return

					// Create spell elements
					let previous_level = undefined
					for (const name of character.spells[main_class].known) {
						const spell = database[name]
						const spell_image = spell_school_images[spell.school]

						// Add spacing between levels
						if (previous_level != spell.level) {
							const text = spell.level == "cantrip" ? capitalize(spell.level) + "s" : spell.level + " Level Spells"
							abilities_container.appendChild({tag: "div", style: {paddingTop: "1.5vh", fontWeight: "bold"}, text: text})
							previous_level = spell.level
						}

						// Conditions
						const spellIsMemorized = character.spells[main_class]?.memorized?.includes(spell.name) || false
						const spellIsCantrip = spell.level == "cantrip"

						// Add element
						abilities_container.appendChild(
							{tag: "div", 
								attributes: {class: "collapsible-div"}, 
								style: {
									display: "flex", gap: "1vh", padding: "0.5vh", marginTop: "1vh",
									opacity: spellIsMemorized || spellIsCantrip || !spellcasting.memorization ? 1 : 0.4
								},
								events: {
									mousedown: (event) => {
										switch (event.button) {
											case 0: // Left Click
												break
											case 2: { // Right Click
												// Buttons
												const buttons = {
													"Description": () => spellDescription(spell),
												}

												// Conditional buttons
												if (spellcasting.memorization) {
													if(!spellIsMemorized && !spellIsCantrip) buttons["Memorize"] = async function () {
														const result = await backend(`impersonated().memorize_spell("` + main_class + `", "` + spell.name + `")`)
														
														// Show warning if no memorization occurred
														if (!result) warning(
															{parent: document.getElementById("abilities-tab"), text: "You have reached memorization limit."}
														)

														updateAbilitiesTab()
													}
													if(spellIsMemorized) buttons["Forget"] =  () => {
														backend(`impersonated().forget_spell("` + main_class + `", "` + spell.name + `")`)
														updateAbilitiesTab()
													}
												}

												// Run context menu
												context_menu({event: event, buttons: buttons})
												break
											}
										}
									}
								},
								children: [
									{tag: "img", attributes: {src: spell_image}},
									{tag: "span", text: name},
									{tag: "span", style: {position: "absolute", right: "0.5vh"}, text: capitalize(spell.level)},
								]
							}
						)
					}
				}
				updateSpells()
			}

			//=====================================================================================================
			// Create HTML
			//=====================================================================================================

			function loadPage() {

				// Loading main div, tabs, and context menu
				create_tabs({content:["character","inventory","abilities"], parent: document.body})

				// Hide containers
				const container_options = {div: {attributes: {class: "hidden"}, style: {paddingBottom: "1vh"}}}

				// Character tab
				document.getElementById("character-tab").appendChildren([
					{tag: "div", attributes: {id: "character-tab-left"}, children: [
						container({id: "saving-throws", title: "Saving Throws"}),
						container({id: "skills", title: "Skills"})
					]},
					{tag: "div", attributes: {id: "character-tab-center"}, children: [
						{tag: "div", style: {height: "1vh"}},

						subtitle({text: "Name"}),
						{tag: "h2", attributes: {id: "name"}},

						{tag: "div", style: {position: "relative", width: "fit-content", margin: "auto"}, children: [
							{tag: "div",
								attributes: {class: "exp-bar", id: "experience"},
								style: {background: "rgba(0,0,0,0.15)"},
								children: [
									{tag: "img", attributes: {id: "portrait"}},
								]
							},
							{tag: "div",
								attributes: {
									id: "level-div",
									class: "tooltip",
								},
								children: [
									{tag:"span", text: "", attributes: {id: "level"}}]
							}
						]},

						{tag: "div", children: [
							subtitle({text: "Class"}),
							{tag: "h2", attributes: {id: "class"}},
						]},

						container({title: "Ability Scores", options: {div: {style: {marginTop: "5vh"}}}, children: [
							ability_scores()
						]}),

						{tag: "br"},

						container({id: "info", title: "Info", options: {content: {style: {marginTop: "-1vh", marginBottom: "2vh"}}}}),
					]},
					{tag: "div", attributes: {id: "character-tab-right"}, children: [
						container({title: "Conditions", id: "character-conditions", options: container_options}),
						container({title: "Resistances", id: "character-resistances", options: container_options}),
						container({title: "Features", id: "character-features", options: container_options}),
						container({title: "Proficiencies", id: "character-proficiencies", options: container_options}),
					]}
				])

				// Inventory tab
				document.getElementById("inventory-tab").appendChildren([
					{tag: "div", style: {width: "45%", left: "27.5%", position: "relative", marginBottom: "3.5vh"}, children: [
						container({title: "Equipment", options: {div: {style: {height: "41vh"}}}, children: [
							{tag: "div", style: {margin: "auto", width: "fit-content"}, children: [
								// Equipment
								{tag: "div", 
									attributes: {
										id: "equipment", 
										class: "center-horizontal"
									},
									style: {
										position: "relative",
										display: "grid",
										gridTemplateColumns: "repeat(5, 1fr)",
										gap: 0,
										textAlign: "center",
										placeItems: "center",
										marginTop: "2vh"
									}
								},
								// Armor Class
								{tag: "div",
									attributes: {
										id: "armor-class",
										tooltip: "Armor Class"
									},
									style: {
										border: "0.3vh solid #444",
										backgroundColor: "#333",
										padding: "1vh",
										fontWeight: "bold",
										fontSize: "120%",
										borderRadius: "50%", borderTopLeftRadius: "0.3vh", borderTopRightRadius: "0.3vh",
										marginTop: "1vh",
										position: "absolute",
										width: "2vh",
										right: "2vh",
										top: "4vh"
									}
								}
							]}
						]}),
					]},
					container({title: "Backpack", options: {div: {style: {width: "85%"}}}, children: [
						{tag: "div", 
							attributes: {id: "inventory"},
							style: {
								position: "relative",
								width: "fit-content",
								margin: "auto",
								display: "grid",
								gridTemplateColumns: "repeat(12, 1fr)",
								gridRowGap: "0.2vh",
								gap: 0,
								marginTop: "2vh"
							}
						}
					]})
				])
			
				// Abilities tab
				document.getElementById("abilities-tab").appendChildren([
					{tag: "div", style: {position: "absolute", left: "1%", width: "50%"}, children: [
						container({title: "Abilites & Spells", id: "abilities-tab-abilities", scroll: true, options: {
							div: {style: {height: "80vh"}},
						}})
					]},
				])
			}

			//=====================================================================================================
			// Execution
			//=====================================================================================================

			function updatePage () {
				// Run first time
				closeIfNotImpersonated()
				updateInventoryTab()
				updateCharacterTab()
				updateAbilitiesTab()

				// Set update intervals
				setInterval(()=> {
					closeIfNotImpersonated()
					updateInventoryTab()
					updateAbilitiesTab()
				}, 500)
				setInterval(() => updateCharacterTab(), 1000)
			}

			window.onload = function () {
				loadPage()
				updatePage()
			}

			//=====================================================================================================
	
		</script>
		']
	</head>
	
	<body>
	</body>
	
	}]