[dialog5("Character Sheet", "width=800; height=800; temporary=0; input=1; noframe=0"), code: {
	<head>
		
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
		<link rel="stylesheet" type="text/css" href="style.css@lib:front"></link>
		[r:scriptTag("open")][r:importScript("images.js@lib:front")][r:scriptTag("close")]
		[r:scriptTag("open")][r:importScript("script.js@lib:front")][r:scriptTag("close")]
		[r:scriptTag("open")][r:importScript("components_new.js@lib:front")][r:scriptTag("close")]
		[r:'
	
		<style>
			#level-div {
				position: absolute; 
				right: 0;  
				bottom: 0; 
				margin: 0; 
				font-size: 130%;
				background-color: #292929;
				border: 0.2vh solid #555;
				border-radius: 100%;
				height: 4.5vh;
				width: 4.5vh;
			}
			#level-div > span {
				position: relative;
				color: #ddd;
				top: 25%;
				font-weight: bold;
			}

			#level-div.level-up {
				cursor: pointer;
			}

			#level-div.level-up:hover {
				background-color: #666;
				cursor: pointer;
			}

			#character-tab-left {
				position:absolute;
				width:33%;
				height:98%;
				left:0;
				top:1%;
	
				overflow-y:inherit
			}
			#character-tab-center {
				position:absolute;
				left: 33%;
				width:34%;
				height:100.5%;
				bottom: -0.5vh;
	
				background-color:#2d2d2d; 
				border: 0.2vh solid #444;
				border-bottom: none;
	
				overflow-y:inherit;
			}
			#character-tab-right {
				position:absolute;
				width:33%;
				height:98%;
				right:0;
				top:1%;
	
				overflow-y:inherit;
			}

			#character-tab-right .container {
				padding-top: 2vh;
				padding-right: 0;
				padding-left: 0;
				padding-bottom: 0;

				width:85%;
			}

			#portrait {
				height:15vh; 
				border-radius: 50%; 
				border: 0.3vh solid #444;
			}

			hr {
				border: 0.1vh solid #444;
				display:block;
				width: 100%;
				margin:auto;
				margin-top: 2vh;
				margin-bottom: 0;
			}

			#character-tab-right .table-header {
				margin-bottom: -1.5vh;
			}
			#character-tab-left .container {
				padding-top:0vh;
				padding-bottom: 2vh;
			}

			#ability-scores-container-content > .table-container {
				margin-right:-1.5vh;
				margin-left:-1.5vh;
				
			}

			.item-selected {
				background-color: #3a3a3a;
			}

			.tooltip.tooltip-bottom::after {
				top: 120%;
			}

			/*=====================================================================================================*/
			/* XP bar */
			/*=====================================================================================================*/

			.exp-bar {
				position: relative;
				width: 17vh;
				height: 17vh;
				margin: -0.5vh 0px;
		
				background: rgba(0,0,0,0.15);
				border-radius: 50%;
				border: 0.2vh solid #444;
		
				display: flex;
				justify-content: center;
				align-items: center;
			}
		</style>
	
		<script>

			//=====================================================================================================
			// Helper functions
			//=====================================================================================================

			function warning({parent, text}) {
				modal({parent: parent, children: [
					{tag: "p", style: {textAlign: "center", fontWeight: "bold", fontSize: "110%", marginTop: "0.5vh"}, text: "Warning"},
					{tag: "p", text: text},
					{tag: "button", text: "Close", events:{click: close_modal}}
				]})
			}
			function title_value({title, value}) {
				return {tag: "div", attributes: {class: "collapsible-div"}, 
				style: {
					display: "flex", gap: "1vh", padding: "0.5vh", marginTop: "1vh", marginBottom: "-0.8vh",
					backgroundColor: "rgba(0,0,0,0)", border: "none",
				}, 
				children: [
					{tag: "span", style: {filter: "brightness(0.8)", fontWeight: "300"}, text: title},
					{tag: "span", style: {position: "absolute", fontWeight: "bold", right: "0.5vh"}, text: value}
				]}
			}
			function title_value_simple({title, value}) {
				return {tag: "p", style: {margin: "0.3vh", padding: "0"}, children: [
					{tag: "span", style: {fontWeight: "bold"}, text: title + ": "},
					{tag: "span", style: {color: "#aaa"}, text: value},
				]}
			}
			function updateEXPBar(percent) {
				function crunchNumber(num, from = [0, 100], to = [0, 100]) {
					// Define the input and output ranges
					const inputMin = from[0];
					const inputMax = from[1];
					const outputMin = to[0];
					const outputMax = to[1];
					
					// Calculate the proportion and map to new range
					const proportion = (num - inputMin) / (inputMax - inputMin);
					const crunched = outputMin + proportion * (outputMax - outputMin);
					
					return crunched;
				}
				// Crunching
				const from = [0, 100]
				const to = [0, 100]

				const start_percent = crunchNumber(percent, from, to)
				const end_percent = crunchNumber(percent == 0 ? 0 : percent + 1, from, to)
				const color = percent >= 100 ? "#ddd" : "#782f78"

				getId("experience").style.background = `linear-gradient(0deg, ` + color + ` ` + start_percent + `%, rgba(0,0,0,0.15) ` + end_percent + `%)`
			}
			function bonusOf(number, parenthesis=false) {
				number = Number(number) > 0 ? "+"+number : number
				number = parenthesis ? "("+number+")" : number

				return String(number)
			}
			function subtitle({text}) {
				return {tag: "p", text, style: {opacity: "0.8", fontWeight: "bold", fontSize: "110%", marginBottom:"-1.5vh"}}
			}
			function ability_scores() {
					function gridItem(text, id="") {
						return {tag: "div",
							style: {
								fontWeight: "bold",
								textAlign: "center"
							},
							attributes: {id},
							text
						}
					}

					return element(
						{tag: "div",
							style: {
								display: "grid",
								marginTop: "1vh",
								gridTemplateColumns: "repeat(6, 1fr)",
								gridTemplateRows: "repeat(2, auto)",
							},
							children: [
								gridItem("STR"),
								gridItem("DEX"),
								gridItem("CON"),
								gridItem("WIS"),
								gridItem("INT"),
								gridItem("CHA"),

								gridItem("0", "strength"),
								gridItem("0", "dexterity"),
								gridItem("0", "constitution"),
								gridItem("0", "wisdom"),
								gridItem("0", "intelligence"),
								gridItem("0", "charisma"),
							]
						}
					)
				}
			function isEqualJSON(a, b) {
				return JSON.stringify(a) === JSON.stringify(b)
			}
			async function closeIfNotImpersonated () {
				if (await backend("impersonated()") == "") {closePage("Character Sheet")}
			}

			//=====================================================================================================
			// Item Dragging
			//=====================================================================================================
						
			let draggedElement = null, initialPosition = null
			function dragstart(event) {
				draggedElement = event.target;
				draggedElement.parentNode.parentNode.parentNode.classList.remove("item-tooltip-container")
				initialPosition = draggedElement.getAttribute("position");
			}
			function dragend(event) {
				draggedElement.style.visibility = "visible";
				draggedElement.parentNode.parentNode.parentNode.classList.add("item-tooltip-container")
			}
			function dragover(event) {
				event.preventDefault();
			}
			function drop(event) {
				event.preventDefault();
				const target = event.target.closest(".inventory-slot");

				if (target) {
					const finalPosition = target.getAttribute("position");

					let request = ` impersonated().move_item(`
					request += !isNaN(Number(initialPosition)) ? initialPosition : `"`+initialPosition+`"`
					request += `, `
					request += !isNaN(Number(finalPosition)) ? finalPosition : `"`+finalPosition+`"`
					request += `)`
					//` impersonated().move_item("`+initialPosition+`", "`+finalPosition+`") `

					toBackend(request)
					updateInventoryTab()

					// Reset draggedElement visibility without moving it
					draggedElement.style.visibility = "hidden";
				}
			}
			
			//=====================================================================================================
			// Modals and context menus
			//=====================================================================================================
			
			// Items
			function itemContext(event, slot, position) {
				if (event.button != 2) return;

				// Define context-menu buttons
				const buttons = {
					"Description": () => {itemDescription(slot)},
					"Unequip": () => {itemUnequip(position)},
					"Split": () => {itemSplit(slot, position)},
					"Send to Target": () => {backend(`impersonated().send_item("`+position+`")`)},
					"Drop": () => {itemDrop(slot, position)},
				}

				// Remove invalid options
				if (!isNaN(Number(position))) delete buttons["Unequip"]
				if (slot.amount == 1) delete buttons["Split"]
				
				context_menu({event: event, buttons: buttons})
			};
			async function itemDescription(slot) {
				// Item from database
				const item = JSON.parse(await backend(`database.get_item("` + slot.name + `")`)) || {}

				// Name
				const name = slot.amount == 1
					? item.name
					: slot.amount + " " + item.name + "s"

				// Subtitle
				const type = item.subtype || item.type
				const rarity = item.rarity == "common"
					? ""
					: item.rarity + " "
				const subtitle = capitalizeAll(rarity + type)

				// Weight
				const weight = Math.round(item.weight * slot.amount * 100) / 100 + "lb"

				// Damage
				let damage = ""
				for (let i = 0 ; i < item.damage.length ; i++) {
					const current = item.damage[i]
					damage += current["die_ammount"] + "d" + current["die_size"] + " " + current["damage_type"].toLowerCase()
					damage += i != item.damage.length - 1 ? ", " : "" // -> adds comma if it is not the last element
				}

				// Other Arrays
				const properties = item.properties.length > 0 != "" ? capitalize(item.properties.join(", ")) : ""
				const conditions = item.conditions.length > 0 != "" ? capitalize(item.conditions.join(", ")) : ""

				modal({parent: document.getElementById("inventory-tab"), children: [
					{tag: "div", style: {padding: "0 1vh"}, children: [
						{tag: "div", 
							style: {textAlign: "center", margin: "1vh", padding: 0, position: "relative", margin: "auto", marginBottom: "2vh", width: "fit-content"}, 
							children: [
								{tag: "span", style: {fontWeight: "bold", fontSize: "110%"}, text: name},
								{tag: "br"},
								{tag: "span", style: {color: "#aaa"}, text: subtitle},
								{tag: "img", attributes: {src: item.image}, style: {position: "absolute", left: "-5.5vh", top: 0, height: "4vh"}}
							]
						},
						{tag: "div", style: {textAlign: "left"}, children: [
							damage ? title_value_simple({title: "Damage", value: damage}) : null,
							item.recovery ? title_value_simple({title: "Recovery Speed", value: String(item.recovery)}) : null,
							item.base_armor_class ? title_value_simple({title: "Armor Class", value: item.base_armor_class}) : null,
							weight ? title_value_simple({title: "Weight", value: weight}) : null,
							properties ? title_value_simple({title: "Properties", value: properties}) : null,
							conditions ? title_value_simple({title: "Conditions", value: conditions}) : null,
						]},
						item.description ? {tag: "pre", style: {color: "#aaa", textAlign: "left"}, text: item.description} : null
					]}
				]})
			}
			async function itemUnequip(position) {
				backend(`impersonated().split_item("`+position+`")`)
			}
			async function itemSplit(slot, position) {
				// Item from database
				const item = JSON.parse(await backend(`database.get_item("` + slot.name + `")`)) || {}

				modal({parent: document.getElementById("inventory-tab"), children: [
					// Collect split amount
					input({id: "modal-split-amount", placeholder: "Ammount to split", options: {div: {style: {width: "70%"}}}}), 
					
					// Spacing
					{tag: "div", style: {height: "1vh"}},

					// Uses drop amount inserted on input field for drop function
					{tag: "button", text: "Split", events: {click: () => {
						const split_amount = document.getElementById("modal-split-amount").value

						backend(`impersonated().split_item("`+position+`", `+split_amount+`)`)
						close_modal()
					}}}
				]})

				// Set value for the input field
				const split_amount = document.getElementById("modal-split-amount")
				split_amount.value = Math.floor(slot.amount / 2)
				split_amount.dispatchEvent(new Event("input"))
			}
			async function itemDrop(slot, position) {
				// If single item in slot automatically drops
				if (slot.amount == 1) {
					backend(`impersonated().drop_item("`+position+`")`)
					return
				}

				// Create modal to ask how many to drop
				modal({parent: document.getElementById("inventory-tab"), children: [
					// Collect drop amount
					input({id: "modal-drop-amount", placeholder: "Ammount to drop", options: {div: {style: {width: "70%"}}}}), 
					
					// Spacing
					{tag: "div", style: {height: "1vh"}},

					// Uses drop amount inserted on input field for drop function
					{tag: "button", text: "Drop", events: {click: () => {
						const drop_amount = document.getElementById("modal-drop-amount").value

						backend(`impersonated().drop_item("`+position+`", `+drop_amount+`)`)
						close_modal()
					}}}
				]})

				// Set value for the input field
				const drop_amount = document.getElementById("modal-drop-amount")
				drop_amount.value = slot.amount
				drop_amount.dispatchEvent(new Event("input"))
			}

			// Spells
			function spellDescription(spell) {

				let cast_time = ""
				if (spell.cast_time >= 0) cast_time = spell.cast_time / 2 + " Seconds"
				else if (spell.cast_time == -1) cast_time = "Bonus Action"
				else if (spell.cast_time == -2) cast_time = "Reaction"

				// Show description
				modal({parent: document.getElementById("spells-tab"), children: [
					{tag: "div", style: {padding: "0 1vh"}, children: [
						// Title
						{tag: "div", style: {marginTop: "0.5vh", marginBottom: "2vh"}, children: [
							{tag: "div", style: {fontSize: "120%", fontWeight: "bold", margin: 0}, text: spell.name},
							{tag: "div", style: {color: "#aaa", margin: 0, marginBottom: "1vh"}, text: capitalize(spell.school) + " Spell"},
						]},
						// Attributes
						{tag: "div", style: {textAlign: "left"}, children: [
							spell.classes && title_value_simple({title: "Classes", value: capitalize(spell.classes.join(", "))}),
							spell.components && title_value_simple({title: "Components", value: capitalize(spell.components.join(", "))}),
							spell.target && title_value_simple({title: "Target", value: capitalize(spell.target)}),
							spell.range && title_value_simple({title: "Range", value: capitalize(spell.range)}),
							spell.cast_time && title_value_simple({title: "Casting Time", value: capitalize(cast_time)}),
							spell.duration && title_value_simple({title: "Duration", value: capitalize(spell.duration)}),
						]},
						// Description
						spell.description 
							&& {tag: "pre", style: {color: "#aaa", textAlign: "left", padding: 0, margin: 0, marginTop: "1vh"}, text: spell.description},
						spell.description_higher_levels 
							&& {tag: "pre", style: {color: "#aaa", textAlign: "left", padding: 0, margin: 0, marginTop: "1vh"}, children: [
								{tag: "b", style: {color: "#ddd"}, text: "At Higher Levels: "},
								{tag: "span", text: spell.description_higher_levels}
							]},
					]}
				]})
			}

			// Resources
			async function resourceDescription(resource) {
				// Show description
				modal({parent: document.getElementById("abilities-tab"), children: [
					{tag: "div", style: {padding: "0 1vh"}, children: [
						// Title
						{tag: "div", style: {marginTop: "0.5vh", marginBottom: "2vh"}, children: [
							{tag: "div", style: {fontSize: "120%", fontWeight: "bold", margin: 0}, text: resource.name},
							{tag: "div", style: {color: "#aaa", margin: 0, marginBottom: "1vh"}, text: "Resource"},
						]},
						// Attributes
						/* {tag: "div", style: {textAlign: "left"}, children: [
							spell.classes && title_value({title: "Classes", value: capitalize(spell.classes.join(", "))}),
							spell.components && title_value({title: "Components", value: capitalize(spell.components.join(", "))}),
							spell.target && title_value({title: "Target", value: capitalize(spell.target)}),
							spell.range && title_value({title: "Range", value: capitalize(spell.range)}),
							spell.cast_time && title_value({title: "Casting Time", value: capitalize(spell.cast_time)}),
							spell.duration && title_value({title: "Duration", value: capitalize(spell.duration)}),
						]}, */
						// Description
						{tag: "pre", style: {color: "#aaa", textAlign: "left", padding: 0, margin: 0, marginTop: "1vh"}, 
							text: (resource.description || await backend(`database.features.data["`+resource.name+`"].description`))
						}
					]}
				]})
			}

			// Abilities
			async function abilityDescription(ability) {
				// Show description
				modal({parent: document.getElementById("abilities-tab"), children: [
					{tag: "div", style: {padding: "0 1vh"}, children: [
						// Title
						{tag: "div", style: {marginTop: "0.5vh", marginBottom: "2vh"}, children: [
							{tag: "div", style: {fontSize: "120%", fontWeight: "bold", margin: 0}, text: ability.name},
							{tag: "div", style: {color: "#aaa", margin: 0, marginBottom: "1vh"}, text: ability.origin + " Ability"},
						]},
						// Attributes
						/* {tag: "div", style: {textAlign: "left"}, children: [
							spell.classes && title_value({title: "Classes", value: capitalize(spell.classes.join(", "))}),
							spell.components && title_value({title: "Components", value: capitalize(spell.components.join(", "))}),
							spell.target && title_value({title: "Target", value: capitalize(spell.target)}),
							spell.range && title_value({title: "Range", value: capitalize(spell.range)}),
							spell.cast_time && title_value({title: "Casting Time", value: capitalize(spell.cast_time)}),
							spell.duration && title_value({title: "Duration", value: capitalize(spell.duration)}),
						]}, */
						// Description
						{tag: "pre", style: {color: "#aaa", textAlign: "left", padding: 0, margin: 0, marginTop: "1vh"}, 
							text: (ability.description || await backend(`database.features.data["`+ability.name+`"].description`))
						}
					]}
				]})
			}

			// Notes
			async function addNote() {
				modal({parent: document.getElementById("journal-tab"), options: {content: {style: {padding: "1vh"}}}, children: [
					{tag: "div", attributes: {class: "input-container"}, style: {margin: 0}, children: [
						input({id: "modal-note-title", placeholder: "Title", options: {div: {style: {marginTop: "1vh", width: "99%"}}}}),
						textarea({id: "modal-note-text", placeholder: "Content", 
							options: {
								div: {style: {marginTop: "1vh"}},
								placeholder: {style: {top: 0}},
								input: {style: {borderStyle: "solid", borderRadius: "0.5vh", marginTop: "3vh", height: "10vh"}}
							}
						})
						/* {tag: "textarea", 
							attributes: {class: "input-container"},
							style: {border: "1px solid #888", borderRadius: "0.5vh", height: "20vh"}
						} */
					]}
				]})
			}

			//=====================================================================================================
			// Update Page
			//=====================================================================================================

			let character_tab = {
				basic: {}, info: {}, skills: {}, saving_throws: {}, 
				conditions: {}, features: {}, proficiencies: {}, resistances: {}
			}
			async function updateCharacterTab() {
				// Character
				const character = JSON.parse(await backend(`JSON.stringify(
					{
						basic: {
							name: impersonated().name,
							portrait: impersonated().portrait,
							level: impersonated().level,
							experience: impersonated().experience,
							level_up_experience: impersonated().level_up_experience || 0,
							classes: impersonated().classes,
							ability_scores: impersonated().ability_scores,
						},
						info: {
							"Type": impersonated().type,
							"Race": impersonated().race,
							" ":" ",
							"  ":"",
							"Health": impersonated().health + " / " + impersonated().max_health,
							"Armor Class": impersonated().armor_class,
							"Initiative": 0,
							"Passive Perception": 10,
							"Walking Speed": impersonated().speed + "ft",
						},
						skills: impersonated().skills,
						saving_throws: impersonated().saving_throws,
						conditions: impersonated().conditions,
						features: impersonated().features,
						proficiencies: impersonated().proficiencies,
						resistances: impersonated().resistances
					}
				)`))

				// Cancel execution if there is no update to character
				if (isEqualJSON(character_tab, character)) { return }

				// Database
				const database = JSON.parse(await backend(`JSON.stringify(
					{
						conditions: database.conditions.data,
						features: database.features.data,
						proficiencies: database.proficiencies.data, proficiencies_ordered: database.get_proficiencies_list(),
						damage_types: database.damage_types.data
					}
				)`))

				// Update name, portrait, class, and ability scores
				function updateBasicAttributes () {
					if (!isEqualJSON(character_tab.basic, character.basic)) {
						character_tab.basic = character.basic
						const experiencePercent = (character.basic.experience / character.basic.level_up_experience) * 100

						document.getElementById("name").textContent = character.basic.name
						document.getElementById("portrait").setAttribute("src", character.basic.portrait)

						// Level and Experience bar
						const level_div = document.getElementById("level-div")
						level_div.clearChildren()
						updateEXPBar(experiencePercent)
						if(character.basic.experience >= character.basic.level_up_experience && character.basic.level < 20) {
							level_div.classList.add("level-up")
							level_div.setAttribute("tooltip", "Click here to level up!")
							level_div.appendChild({tag:"img", 
								attributes: {src: "asset://5282add24bd7663d499861e313980245"}, 
								style: {height: "1.5em", marginTop: "0.7vh", cursor: "pointer"},
								events: {click: () => openPage("character_level_up.html", "")}
							})
						}
						else {
							level_div.classList.remove("level-up")
							level_div.setAttribute("tooltip", character.basic.level < 20 ? character.basic.experience + " / " + character.basic.level_up_experience + " XP" : "Maximum Level")
							level_div.appendChild({tag:"span", text: String(character.basic.level)})
						}

						// Classes text
						let class_text = ""
						for (const cls in character.basic.classes) {
							class_text += class_text ? " / " : ""
							class_text += capitalize(cls) + (Object.keys(character.basic.classes).length > 1 ? " " + character.basic.classes[cls].level : "")
						}
						document.getElementById("class").textContent = class_text || "None"

						// Ability Scores
						for (const score in character.basic.ability_scores) {
							document.getElementById(score).textContent = character.basic.ability_scores[score]
						}
					}
				}
				updateBasicAttributes ()

				// Update info area
				function updateInfo () {
					if (!isEqualJSON(character_tab.info, character.info)) {
						character_tab.info = character.info

						// Clear Skills
						const info_container = document.getElementById("info")
						info_container.clearChildren()

						// Append Skills with bonuses
						for (const title in character.info) {
							const value = character.info[title] + ""
							info_container.appendChild(title_value({title, value}))
						}
					}
				}
				updateInfo ()

				// Update skills
				function updateSkills () {
					if (!isEqualJSON(character_tab.skills, character.skills)) {
						character_tab.skills = character.skills

						// Clear Skills
						const skills_container = document.getElementById("skills")
						skills_container.clearChildren()

						// Append Skills with bonuses
						for (const skill in character.skills) {
							const title = capitalize(skill)
							const value = bonusOf(character.skills[skill])
							skills_container.appendChild(title_value({title, value}))
						}
					}
				}
				updateSkills()

				// Update saving throws
				function updateSavingThrows () {
					if (!isEqualJSON(character_tab.saving_throws, character.saving_throws)) {
						character_tab.saving_throws = character.saving_throws

						// Clear Saving Throws
						const saving_throws_container = document.getElementById("saving-throws")
						saving_throws_container.clearChildren()

						// Append Saving Throws with bonuses
						for (const score of ["strength", "dexterity", "constitution", "wisdom", "intelligence", "charisma"]) {
							const title = capitalize(score)
							const value = bonusOf(character.saving_throws[score])
							saving_throws_container.appendChild(title_value({title, value}))
						}
					}
				}
				updateSavingThrows()

				// Update conditions
				function updateConditions () {
					if (!isEqualJSON(character_tab.conditions, character.conditions)) {
						character_tab.conditions = character.conditions

						// Clear conditions
						const conditions = document.getElementById("character-conditions")
						conditions.clearChildren()

						// Append Conditions
						for (const name in character.conditions) {
							// From character
							const duration = (
								character.conditions[name].duration != -1 
								? timeUnit(character.conditions[name].duration) 
								: ""
							)

							// From database
							const condition = database.conditions[name] || {}
							const description = condition?.description || "Description unavailable"
							const image = condition?.image || condition_images[condition?.type] || ""

							// Element
							collapsible(
								{parent: conditions,
									options: {
										button: {style: {display: "flex", gap: "1vh", padding: "0.5vh", margin: "0 1vh"}},
										content: {style: {marginRight: "1.3vh", marginLeft: "1.3vh"}}
									},
									button_children: [
										{tag: "img", attributes: {src: image}},
										{tag: "span", text: name},
										{tag: "span", style: {position: "absolute", right: "1vh"}, text: duration}
									],
									children: [
										{tag: "pre", style: {fontSize: "90%"}, text: description}
									]
								}
							)
						}

						// Hide container if empty
						if (conditions.children.length == 0) { 
							conditions.parentElement.classList.add("hidden") 
						} 
						else { 
							conditions.parentElement.classList.remove("hidden") 
						}
					}
				}
				updateConditions()

				// Update features
				function updateFeatures () {
					if (!isEqualJSON(character_tab.features, character.features)) {
						character_tab.features = character.features

						// Clear container
						const features = document.getElementById("character-features")
						features.clearChildren()

						// Append features
						for (const name of character.features) {
							// From database
							const feature = database.features[name]
							const type = feature.subtype || feature.type || "None"
							const image = class_images[type] || feature_images[type] || ""
							const description = feature.description || "Description unavailable"

							// Element
							collapsible(
								{parent: features,
									options: {
										button: {style: {display: "flex", gap: "1vh", padding: "0.5vh", margin: "0 1vh"}},
										content: {style: {marginRight: "1.3vh", marginLeft: "1.3vh"}}
									},
									button_children: [
										{tag: "img", attributes: {src: image}},
										{tag: "span", text: name}
									],
									children: [
										{tag: "pre", style: {fontSize: "90%"}, text: description}
									]
								}
							)
						}

						// Hide container if empty
						if (features.children.length == 0) { 
							features.parentElement.classList.add("hidden") 
						} 
						else { 
							features.parentElement.classList.remove("hidden") 
						}
					}
				}
				updateFeatures()

				// Update features
				function updateProficiencies () {
					if (!isEqualJSON(character_tab.proficiencies, character.proficiencies)) {
						character_tab.proficiencies = character.proficiencies

						// Ordered proficiencies
						const character_proficiencies_ordered = database.proficiencies_ordered.filter(
							item => Object.keys(character.proficiencies).includes(item)
						)

						// Clear container
						const proficiencies = document.getElementById("character-proficiencies")
						proficiencies.clearChildren()

						// Append Conditions
						for (const name of character_proficiencies_ordered) {
							// From character
							const level = Number(character.proficiencies[name])

							// From database
							const proficiency = database.proficiencies[name]
							if (!proficiency) { continue }
							
							const type = proficiency.type || "None"
							const description = proficiency.description.slice(0, level + 1) || ""
							const image = proficiency_images[type] || ""
							const level_title = " " + ["", "Expertise", "Mastery", "Grandmastery"][level]

							// Skip certain types
							if (["skill"].includes(type)) {continue}

							// Create description
							const children = []
							for (const text of description) {
								children.push(
									{tag: "pre", style: {fontSize: "90%"}, text}
								)
							}

							// Element
							collapsible(
								{parent: proficiencies,
									options: {
										button: {style: {display: "flex", gap: "1vh", padding: "0.5vh", margin: "0 1vh"}},
										content: {style: {marginRight: "1.3vh", marginLeft: "1.3vh"}}
									},
									button_children: [
										{tag: "img", attributes: {src: image}},
										{tag: "span", text: name + (type == "language" ? "" : level_title)}
									],
									children
								}
							)

							// Hide container if empty
							if (proficiencies.children.length == 0) { 
								proficiencies.parentElement.classList.add("hidden") 
							} 
							else { 
								proficiencies.parentElement.classList.remove("hidden") 
							}
						}
					}
				}
				updateProficiencies()

				// Update resistances
				function updateResistances () {
					// Update
					if (!isEqualJSON(character_tab.resistances, character.resistances)) {
						character_tab.resistances = character.resistances

						// Clear container
						const resistances = document.getElementById("character-resistances")
						resistances.clearChildren()

						// Append Conditions
						for (const name in character.resistances) {
							// From character
							const {type, reduction} = character.resistances[name]

							// Skip if resistance has default values
							if (type == "default" && reduction == 0) {continue}

							// From database
							const damage_type = database.damage_types[name]
							const image = damage_type.image
							const description = damage_type.description

							// Resistance value shown
							const resistance = type != "default" ? capitalize(type) : reduction

							// Element
							collapsible(
								{parent: resistances,
									options: {
										button: {style: {display: "flex", gap: "1vh", padding: "0.5vh", margin: "0 1vh"}},
										content: {style: {marginRight: "1.3vh", marginLeft: "1.3vh"}}
									},
									button_children: [
										{tag: "img", attributes: {src: image}},
										{tag: "span", text: name},
										{tag: "span", style: {position: "absolute", right: "1vh"}, text: String(resistance)}
									],
									children: [
										{tag: "pre", style: {fontSize: "90%"}, text: description}
									]
								}
							)
						}

						// Hide container if empty
						if (resistances.children.length == 0) { 
							resistances.parentElement.classList.add("hidden") 
						} 
						else { 
							resistances.parentElement.classList.remove("hidden") 
						}
					}
				}
				updateResistances()
			}

			let inventory_tab = {
				basic: {},
				equipment: {},
				inventory: []
			}
			async function updateInventoryTab() {
				// Character Items
				const character = JSON.parse(await backend(`JSON.stringify(
					{
						basic: {
							"armor_class": impersonated().armor_class,
							"initiative_mod": impersonated().initiative_mod,
							"carry_weight": impersonated().carry_weight,
							"score_bonus": impersonated().score_bonus,
							"damage_modifiers": Common.calculate_weapon_attack_damage_modifiers(impersonated())
						},
						equipment: impersonated().equipment,
						inventory: impersonated().inventory
					}
				)`))

				// Cancel execution if there is no update to character
				if (isEqualJSON(inventory_tab, character)) { return }

				// Database
				const database = JSON.parse(await backend(`database.items.data`))

				// Basic Attributes
				function updateBasicAttributes() {
					inventory_tab.basic = character.basic

					// Clear
					const info_div = document.getElementById("inventory-tab-info")
					info_div.clearChildren()

					const weapons_stats = []

					// Main Hand Stats
					const main_hand = database[character.equipment["primary main hand"]?.name]
					if (main_hand?.subtype == "weapon") {
						const isFinesse = main_hand.properties.includes("Finesse")
						const isAmmo = main_hand.properties.includes("Ammunition")

						// Damage Modifier
						const str_bonus = character.basic.score_bonus["strength"]
						const dex_bonus = isFinesse || isAmmo ? character.basic.score_bonus["dexterity"] : 0
						const damage_bonus = Math.max(str_bonus, Math.min(dex_bonus, 3)) + character.basic.damage_modifiers
						const hit_bonus = Math.max(Math.min(str_bonus, 3), dex_bonus) + 2

						// Add up weapon damages
						let minimum = damage_bonus, maximum = damage_bonus
						for (const damage of main_hand.damage) {
							minimum += Number(damage.die_ammount)
							maximum += Number(damage.die_size) * Number(damage.die_ammount)
						}

						// Element
						weapons_stats.push(
							title_value({title: character.equipment["primary main hand"]?.name + " Damage", value: minimum + " - " + maximum}),
							title_value({title: character.equipment["primary main hand"]?.name + " Hit Bonus", value: hit_bonus > 0 ? "+" + hit_bonus : hit_bonus})
						)
					}
					
					// Off Hand Stats
					const off_hand = database[character.equipment["primary off hand"]?.name]
					if (off_hand?.subtype == "weapon") {
						const isFinesse = off_hand.properties.includes("Finesse")
						const isAmmo = off_hand.properties.includes("Ammunition")

						// Damage Modifier
						const str_bonus = character.basic.score_bonus["strength"]
						const dex_bonus = isFinesse || isAmmo ? character.basic.score_bonus["dexterity"] : 0
						const damage_bonus = 0 + character.basic.damage_modifiers
						const hit_bonus = Math.max(Math.min(str_bonus, 3), dex_bonus) + 2

						// Add up weapon damages
						let minimum = damage_bonus, maximum = damage_bonus
						for (const damage of off_hand.damage) {
							minimum += Number(damage.die_ammount)
							maximum += Number(damage.die_size) * Number(damage.die_ammount)
						}

						// Element
						weapons_stats.push(
							weapons_stats.length > 0 && {tag:"br"},
							title_value({title: character.equipment["primary off hand"]?.name + " Damage", value: minimum + " - " + maximum}),
							title_value({title: character.equipment["primary off hand"]?.name + " Hit Bonus", value: hit_bonus > 0 ? "+" + hit_bonus : hit_bonus})
						)
					}

					// Weight
					let weight_style = character.basic.carry_weight.current > character.basic.carry_weight.encumberance ? {color: "yellow"} : {}
					weight_style = character.basic.carry_weight.current > character.basic.carry_weight.max ? {color: "red"} : weight_style

					info_div.appendChildren([
						title_value({title: "Armor Class", value: character.basic.armor_class}),
						title_value({title: "Initiative Penalty", value: (character.basic.initiative_mod && "+") + character.basic.initiative_mod}),
						{tag: "br"},
						...weapons_stats,
						{tag: "div", style: {position: "absolute", bottom: "1vh", width: "87.5%"}, children: [
							{tag: "div", attributes: {class: "collapsible-div"}, 
								style: {
									display: "flex", gap: "1vh", padding: "0.5vh", marginTop: "1vh", marginBottom: "-0.8vh",
									backgroundColor: "rgba(0,0,0,0)", border: "none",
								}, 
								children: [
									{tag: "span", style: {filter: "brightness(0.8)", fontWeight: "300"}, text: "Carry Weight"},
									{tag: "span", style: {position: "absolute", fontWeight: "bold", right: "0.5vh"}, children: [
										{tag: "span", style: weight_style, text: character.basic.carry_weight.current},
										{tag: "span", text: " / "},
										{tag: "span", text: character.basic.carry_weight.encumberance},
										{tag: "span", text: " lb"},
									]}
								]
							}	
						]}
					])
				}
				updateBasicAttributes()

				// Equipment
				function updateEquipment() {
					// Verify if equipment received changes
					if (isEqualJSON(inventory_tab.inventory, character.inventory) && isEqualJSON(inventory_tab.equipment, character.equipment)) { return }
					inventory_tab.equipment = character.equipment

					// Clear Equipment
					const equipment = document.getElementById("equipment")
					equipment.clearChildren()

					// Create slots
					const equipment_slot_positions = [
						"", "amulet", "head", "ammunition", "",
						"","hands", "body", "cape", "",
						"","left ring","belt","right ring", "",
						"","","feet","","",
						"","","","","",
						"","","","","",
						"primary main hand", "primary off hand", "", "secondary main hand", "secondary off hand",
					]
					for (const position of equipment_slot_positions) {
						// Defining slot from equipment, item from database
						const slot = character.equipment[position]
						const item = slot ? database[slot.name] : null
						
						// Offhand ~ Mainhand slot verification
						let isTwoHanded = false, two_hand_image
						if (position.includes("off hand")) {
							// Gathering main hand information
							const main_hand_position = position.includes("primary") ? "primary main hand" : "secondary main hand"
							const slot = character.equipment[main_hand_position]
							const item = slot ? database[slot.name] : null

							// Updates variables based on main hand information
							if (item) {
								isTwoHanded = item.properties.includes("Two-handed")
								two_hand_image = item.image
							}
						}

						// Item element creation
						let image = null, amount = null
						if (item) { // --> Slot contains item
							// Tooltip
							const name = slot.amount > 1 ? slot.amount + " " + item.name + "s" : item.name
							const weight = " (" + Math.round(item.weight * slot.amount * 100) / 100 + "lb)"
							const tooltip = name + " " + weight

							// Item amount (when slot amount > 1)
							amount = slot.amount > 1
								? {tag: "span", attributes: {class: "inventory-item-amount"}, style: {pointerEvents: "none"}, text: String(slot.amount)}
								: null

							// Item image
							image = 
							 {tag: "span", attributes: {class: "tooltip tooltip-bottom", tooltip: tooltip}, children: [
								{tag: "img",
									attributes: {
										src: item.image,
										draggable: "true",
										class: "inventory-item",
										position: position,
									},
									events: {
										dragstart, 
										dragend, 
										mousedown: (event)=> itemContext(event, slot, position),
									}
								}
							]}
						} 
						else if (isTwoHanded) { // --> No item on slot but two-handed weapon
							image = 
								{tag: "img",
									attributes: {
										src: two_hand_image,
										class: "inventory-item",
										position: position
									},
									style: {opacity: "0.2", cursor: "default"}
								}
						}
						else { // --> Empty slot, receives placeholder image
							image = 
								{tag: "img",
									style: {
										filter: "brightness(100)",
										opacity: "0.05",
										position: "relative",
										height: "85%",
										top: "7.5%",

										// Prevent dragging of placeholder image
										userSelect: "none",
										pointerEvents: "none"
									},
									attributes: {src: equipment_images[position]},
								}
						}

						// Slot
						if (position) {
							// Reduce opacity on secondary weapon set
							const style = position.includes("secondary") ? {opacity: 0.7, border: "none", padding: "0.2vh"} : {}

							// Element
							equipment.appendChild(
								{tag: "div", 
									attributes: {
										class: "inventory-slot item-tooltip-trigger",
										position: position
									},
									style: style,
									events: {dragover, drop},
									children: [image, amount]
								}
							)
						}
						else {equipment.appendChild({tag: "div"})} // --> add empty div to fill grid
					}
				}
				updateEquipment()

				// Inventory
				function updateInventory() {
					// Verify if inventory received changes
					if (isEqualJSON(inventory_tab.inventory, character.inventory) && isEqualJSON(inventory_tab.equipment, character.equipment)) { return }
					inventory_tab.inventory = character.inventory

					// Clear Equipment
					const inventory = document.getElementById("inventory")
					inventory.clearChildren()

					// Create slots
					for (let position = 0 ; position < character.inventory.length ; position++) {
						// Defining slot from equipment, item from database
						const slot = character.inventory[position]
						const item = slot ? database[slot.name] : null

						// Item element creation
						let image = null, amount = null
						if (item) { // --> Slot contains item
							// Tooltip
							const name = slot.amount > 1 ? slot.amount + " " + item.name + "s" : item.name
							const weight = " (" + Math.round(item.weight * slot.amount * 100) / 100 + "lb)"
							const tooltip = name + " " + weight

							// Item amount (when slot amount > 1)
							amount = slot.amount > 1
								? {tag: "span", attributes: {class: "inventory-item-amount"}, style: {pointerEvents: "none"}, text: String(slot.amount)}
								: null

							// Item image
							image = 
							 {tag: "span", attributes: {class: "tooltip tooltip-bottom", tooltip: tooltip}, children: [
								{tag: "img",
									attributes: {
										src: item.image,
										draggable: "true",
										class: "inventory-item",
										position: position,
									},
									events: {
										dragstart, 
										dragend, 
										mousedown: (event)=> itemContext(event, slot, position)
									}
								}
							]} 
						}

						// Element
						inventory.appendChild(
							{tag: "div", 
								attributes: {
									class: "inventory-slot item-tooltip-trigger",
									position: position
								},
								events: {dragover, drop},
								children: [image, amount]
							}
						)
					}
				}
				updateInventory()
			}

			let abilities_tab = {
				classes: {},
				resources: {},
				abilities: {},
				hasInitiative: false,
			}
			async function updateAbilitiesTab() {
				// Helpers
				function getMainClass(classObj) {
					let highestLevel = -Infinity;
					let highestClass = null;

					for (const [className, class_info] of Object.entries(classObj)) {
						if (class_info.level > highestLevel) {
							highestLevel = class_info.level;
							highestClass = className;
						}
					}

					return highestClass;
				}
				function orderByRestoredOn(obj) {
					const priority = {
						"": -1, // for undefined or missing
						"turn start": 0,
						"short rest": 1,
						"long rest": 2,
					};

					return Object.keys(obj).sort((a, b) => {
						let a_priority = priority[obj[a].restored_on || ""]
						let b_priority = priority[obj[b].restored_on || ""]

						if(a.includes("Spell Slot")) a_priority = 3
						if(b.includes("Spell Slot")) b_priority = 3

						return a_priority - b_priority;
					});
				}

				// Character Attributes
				const character = JSON.parse(await backend(`JSON.stringify(
					{
						classes: impersonated().classes || {},
						resources: impersonated().resources || {},
						hasInitiative: Initiative.turn_order.includes(impersonated().id)
					}
				)`))

				// Character Classes Request
				let classes_actions_list = ""
				for (const item of Object.keys(character.classes)) {
					classes_actions_list += "..." + item + ".actions_list(),"
				}

				// Character Classes
				character["abilities"] = JSON.parse(await backend(`JSON.stringify({
					...Common.actions_list(),
					`+classes_actions_list+`
				})`))

				// Cancel execution if there is no update to character
				if (isEqualJSON(abilities_tab, character)) return

				// Database
				const database = JSON.parse(await backend(`JSON.stringify({
					spells: database.spells.data,
					resources: database.resources.data,
				})`))

				// Update Abilities
				let previous_type = undefined
				async function updateAbilities() {
					// Clear container
					const abilities_container = document.getElementById("abilities-tab-abilities")
					abilities_container.clearChildren()

					// Create ability elements
					for (const name in character.abilities) {
						const ability = character.abilities[name]
						const show_name = ability.name || capitalizeAll(name.replaceAll("_", " "))

						// Add spacing between levels
						const type = ability.origin == "Common" ? "Common Abilities" : "Class Abilities"
						if (previous_type != type) {
							abilities_container.appendChild({tag: "div", style: {margin: "1.3vh", marginTop: "2vh", padding: 0, fontWeight: "bold"}, text: type})
							previous_type = type
						}

						// Resources Element
						const resources = []
						let i = 0
						for (const resource of ability.resources) {
							if (i < (ability.resources.length) && i != 0) resources.push({tag: "span", text: ", "})
							resources.push({tag: "img", style: {position: "relative", bottom: "0.2vh", margin: "0 0.3vh"}, attributes: {src: database?.resources[resource]?.image || ""}})
							resources.push({tag: "span", text: resource})
							i++
						}

						// Add element
						abilities_container.appendChild(
							{tag: "div", 
								attributes: {class: "collapsible-div"}, 
								style: {
									display: "flex", gap: "1vh", padding: "0.5vh", marginTop: "1vh",
								},
								events: {
									mousedown: (event) => {
										if (event.button != 2) return
										const buttons = {
											"Use": () => backend(ability.origin + `.` + name + `()`),
											"Description": () => abilityDescription({...ability, name: show_name}),
										}

										// Run context menu
										context_menu({event: event, buttons: buttons})			
									}
								},
								children: [
									{tag: "img", attributes: {src: ability.image || ""}},
									{tag: "span", text: show_name},
									{tag: "div", style: {position: "absolute", right: "0.5vh", padding: 0, margin: 0}, children: resources},
								]
							}
						)
					}
				}
				updateAbilities()

				// Update Resources
				async function updateResources() {
					if (isEqualJSON(abilities_tab.resources, character.resources) && 
						isEqualJSON(abilities_tab.hasInitiative, character.hasInitiative)) return

					// Clear container
					const resources_container = document.getElementById("abilities-tab-resources")
					resources_container.clearChildren()

					// Create elements
					let previous_restored_on = undefined
					for (const name of orderByRestoredOn(character.resources)) {
						const resource = character.resources[name]
						const resource_data = database.resources[name] || {}
						const color = {color: resource_data.color || ""}

						// Validation
						if(name == "Attack Action" && resource.value <= 0) continue
						if(name.includes("Level Spell Slot")) continue
						if(resource.restored_on == "turn start" && !character.hasInitiative) continue

						// Add spacing between resource types
						const restored_on = resource?.restored_on || ""
						const text = restored_on != "" ? "" + capitalizeAll(restored_on) : "Other"
						if (previous_restored_on != restored_on) {
							resources_container.appendChild({tag: "div", style: {margin: "1.3vh", marginTop: "2vh", padding: 0, fontWeight: "bold"}, text: text})
							previous_restored_on = restored_on
						}

						// Add element
						resources_container.appendChildren([
							{tag: "div", 
								attributes: {class: "collapsible-div"}, 
								style: {
									display: "flex", gap: "1vh", padding: "0.5vh", marginTop: "1vh",
									opacity: resource.value > 0 ? 1 : 0.4
								},
								events: {
									mousedown: (event) => { 
										if (event.button != 2) return
										const buttons = {}
										
										// Use
										if(resource.value > 0 && name != "Movement") buttons["Use"] = async () => {await backend(`impersonated().use_resource("` + name + `")`); updateResources()}
										
										// Description
										if(!isEqualJSON(resource_data, {})) buttons["Description"] = () => resourceDescription(resource_data)

										// Run context menu
										context_menu({event: event, buttons: buttons})
									}
								},
								children: [
									{tag: "img", attributes: {src: resource_data.image}},
									{tag: "span", text: name},
									{tag: "span", style: {position: "absolute", right: "0.5vh"}, children: [
										{tag: "span", style: color, text: resource.value},
										{tag: "span", text: " / "},
										{tag: "span", style: color, text: resource.max},
									]}
								]
							}
						])
					}
				}
				updateResources()

				// Cashing
				abilities_tab = character
			}

			let spells_tab = {
				classes: {},
				spells: {},
				resources: {},
				filters: {},
				spellcasting: {},
				score_bonus: {},
			}
			async function updateSpellsTab() {
				const chosen_class = document.getElementById("spells-tab-class").value || "None"

				// Character Abilities
				const character = JSON.parse(await backend(`JSON.stringify(
					{
						classes: impersonated().classes || {},
						spells: impersonated().spells || {},
						resources: impersonated().resources || {},
						spellcasting: ` + (chosen_class == "None" 
							? `{}` 
							: chosen_class + `.spellcasting`) + `,
						score_bonus: impersonated().score_bonus || {},
					}
				)`))

				// Cancel execution if there is no update to character
				//if (isEqualJSON(spells_tab, character)) return

				// Database
				const { database, spells_list } = JSON.parse(await backend(`JSON.stringify({
					database: {
						spells: database.spells.data,
						resources: database.resources.data,
					},
					spells_list: database.get_spells_list()
				})`))
				
				// Update Class Option
				async function updateClass() {
					if (isEqualJSON(spells_tab.classes, character.classes)) return
					spells_tab.classes = character.classes

					const class_select = document.getElementById("spells-tab-class")
					class_select.clearChildren()

					// Verifies which of the player classes can spellcast
					let classes_search_text = ""
					for (const name in character.classes) {
						classes_search_text += name + `: ` + name + `?.spellcasting || "", `
					}
					const classes_spellcasting = JSON.parse(await backend(`JSON.stringify({
						`+classes_search_text+`
					})`))
					
					// Adds option for all spellcasting classes
					for (const name in classes_spellcasting) {
						if (classes_spellcasting[name] == "") continue

						class_select.appendChild({tag: "option", text: name})
					}
					class_select.dispatchEvent(new Event("change"))
				}
				updateClass()

				// Update Spellcasting
				async function updateSpellcasting() {
					if (isEqualJSON(spells_tab.spellcasting, character.spellcasting) && 
						isEqualJSON(spells_tab.score_bonus, character.score_bonus) && 
						isEqualJSON(spells_tab.spells, character.spells)) return
					spells_tab.spellcasting = character.spellcasting
					spells_tab.score_bonus = character.score_bonus

					const class_info = document.getElementById("spells-tab-class-info")
					class_info.clearChildren()

					if(isEqualJSON(character.spellcasting, {})) {return}

					// Info construction
					const modifier = character.score_bonus[character.spellcasting.ability]
					const values = {
						"Spellcasting Ability": capitalize(character.spellcasting.ability),
						"Spellcasting Modifier": modifier > 0 ? "+" + modifier : modifier,
						"  ":"",
						"Spell Save DC": 10 + modifier,
						"Spell Hit Bonus": modifier + 2 > 0 ? "+" + (modifier + 2) : (modifier + 2),
						"   ":"",
					}

					// Conditional info
					if (character.spellcasting.memorization) {
						values["Spells Memorized"] = (character?.spells[chosen_class]?.memorized?.length || 0) + " / " + (modifier + character.classes[chosen_class].level)
					}

					// Elements
					for (const title in values) {
						const value = values[title]

						class_info.appendChild(title_value({title, value}))
					}
				}
				updateSpellcasting()

				// Update Spells
				async function updateSpells() {
					// Active spells filter
					const showAll = document.getElementById("spells-tab-spells-memorized-only").getAttribute("value") == "false"
					const levelFilter = document.getElementById("spells-tab-spells-level").getAttribute("value")
					if (isEqualJSON(
						{spells: spells_tab.spells, filters: spells_tab.filters},
						{spells: character.spells, filters: {showAll, levelFilter, chosen_class}}
					)) return
					spells_tab.filters = {...spells_tab.filters, showAll, levelFilter, chosen_class}
					spells_tab.spells = character.spells
					
					// Get main class
					const class_spells = character.spells[chosen_class] || {known: []}
					const spellcasting = character.spellcasting

					// Clear container
					const abilities_container = document.getElementById("spells-tab-spells")
					abilities_container.clearChildren()
					if (isEqualJSON(spellcasting, {})) return

					// Create spell elements
					let previous_level = undefined
					for (const name of spells_list.filter(spell => class_spells.known.includes(spell))) {
						const spell = database.spells[name]
						const spell_image = spell_school_images[spell.school]
						
						// Action type
						let action_type
						if (spell.cast_time > 0) action_type =  "Action"
						if (spell.cast_time == -1) action_type = "Bonus Action"
						if (spell.cast_time == -2) action_type = "Reaction"

						// Conditions
						const spellIsMemorized = character.spells[chosen_class]?.memorized?.includes(spell.name) || false
						const spellIsCantrip = spell.level == "cantrip"

						// Validation
						if (!(spellIsCantrip || spellIsMemorized) && !showAll) continue
						if (levelFilter && (levelFilter != spell.level)) continue

						// Add spacing between levels
						if (previous_level != spell.level) {
							abilities_container.appendChild({tag: "div", style: {margin: "1.3vh", marginTop: "2vh", padding: 0, fontWeight: "bold"}, text: spell.level == "cantrip" ? "Cantrips" : spell.level + " Level Spells"})
							previous_level = spell.level
						}

						// Add element
						abilities_container.appendChild(
							{tag: "div", 
								attributes: {class: "collapsible-div"}, 
								style: {
									display: "flex", gap: "1vh", padding: "0.5vh", marginTop: "1vh",
									opacity: spellIsMemorized || spellIsCantrip || !spellcasting.memorization ? 1 : 0.4
								},
								events: {
									mousedown: (event) => {
										switch (event.button) {
											case 0: // Left Click
												break
											case 2: { // Right Click
												// Buttons
												const buttons = {
													"Description": () => spellDescription(spell),
												}

												// Conditional buttons
												if (spellcasting.memorization) {
													if(!spellIsMemorized && !spellIsCantrip) buttons["Memorize"] = async function () {
														const result = await backend(`impersonated().memorize_spell("` + chosen_class + `", "` + spell.name + `")`)
														
														// Show warning if no memorization occurred
														if (!result) warning(
															{parent: document.getElementById("spells-tab"), text: "You have reached memorization limit."}
														)

														updateSpellsTab()
													}
													if(spellIsMemorized) buttons["Forget"] =  () => {
														backend(`impersonated().forget_spell("` + chosen_class + `", "` + spell.name + `")`)
														updateSpellsTab()
													}
												}

												// Run context menu
												context_menu({event: event, buttons: buttons})
												break
											}
										}
									}
								},
								children: [
									{tag: "img", attributes: {src: spell_image}},
									{tag: "span", text: name},
									{tag: "span", style: {position: "absolute", right: "0.5vh"}, text: action_type},
								]
							}
						)
					}
				}
				updateSpells()

				// Update Spell Slots
				async function updateSpellSlots() {
					if (isEqualJSON(spells_tab.resources, character.resources)) return
					spells_tab.resources = character.resources

					// Clear container
					const slot_container = document.getElementById("spells-tab-spell-slots")
					slot_container.clearChildren()

					// Create elements
					for (const key in character.resources) {
						const resource = character.resources[key]
						const resource_data = database.resources[key] || {}
						const color = {color: resource_data.color || ""}

						// Validation
						if(!key.includes("Level Spell Slot")) continue
						const name = key.replace("Spell Slot", "")

						// Add element
						slot_container.appendChild(
							{tag: "div", 
								attributes: {class: "collapsible-div"}, 
								style: {
									display: "flex", gap: "1vh", padding: "0.5vh", marginTop: "1vh",
									opacity: resource.value > 0 ? 1 : 0.4
								},
								events: {
									mousedown: (event) => {
										switch (event.button) {
											case 0: // Left Click
												break
											case 2: { // Right Click
												// Buttons
												const buttons = {}
												
												// Conditional Buttons
												if(resource.value > 0 && name != "Movement") buttons["Use"] = async () => {await backend(`impersonated().use_resource("` + key + `")`); updateSpellSlots()}

												// Run context menu
												context_menu({event: event, buttons: buttons})
												break
											}
										}
									}
								},
								children: [
									{tag: "img", attributes: {src: resource_data.image}},
									{tag: "span", text: name},
									{tag: "span", style: {position: "absolute", right: "0.5vh"}, children: [
										{tag: "span", style: color, text: resource.value},
										{tag: "span", text: " / "},
										{tag: "span", style: color, text: resource.max},
									]}
								]
							}
						)
					}
				}
				updateSpellSlots()
			}

			//=====================================================================================================
			// Create HTML
			//=====================================================================================================

			function loadPage() {

				// Loading main div, tabs, and context menu
				create_tabs({content:["character","inventory","abilities", "spells", "journal"], parent: document.body})

				// Character
				const container_options = {div: {attributes: {class: "hidden"}, style: {paddingBottom: "1vh"}}}
				document.getElementById("character-tab").appendChildren([
					{tag: "div", attributes: {id: "character-tab-left"}, children: [
						container({id: "saving-throws", title: "Saving Throws"}),
						container({id: "skills", title: "Skills"})
					]},
					{tag: "div", attributes: {id: "character-tab-center"}, children: [
						{tag: "div", style: {height: "1vh"}},

						subtitle({text: "Name"}),
						{tag: "h2", attributes: {id: "name"}},

						{tag: "div", style: {position: "relative", width: "fit-content", margin: "auto"}, children: [
							{tag: "div",
								attributes: {class: "exp-bar", id: "experience"},
								style: {background: "rgba(0,0,0,0.15)"},
								children: [
									{tag: "img", attributes: {id: "portrait"}},
								]
							},
							{tag: "div",
								attributes: {
									id: "level-div",
									class: "tooltip",
								},
								children: [
									{tag:"span", text: "", attributes: {id: "level"}}]
							}
						]},

						{tag: "div", children: [
							subtitle({text: "Class"}),
							{tag: "h2", attributes: {id: "class"}},
						]},

						container({title: "Ability Scores", options: {div: {style: {marginTop: "5vh"}}}, children: [
							ability_scores()
						]}),

						{tag: "br"},

						container({id: "info", title: "Info", options: {content: {style: {marginTop: "-1vh", marginBottom: "2vh"}}}}),
					]},
					{tag: "div", attributes: {id: "character-tab-right"}, children: [
						container({title: "Conditions", id: "character-conditions", options: container_options}),
						container({title: "Resistances", id: "character-resistances", options: container_options}),
						container({title: "Features", id: "character-features", options: container_options}),
						container({title: "Proficiencies", id: "character-proficiencies", options: container_options}),
					]}
				])

				// Inventory
				document.getElementById("inventory-tab").appendChildren([
					{tag: "div", style: {width: "100%", position: "relative", height: "45vh"}, children: [
						{tag: "div", style: {width: "30%", left: "1%", position: "absolute", marginBottom: "3.5vh"}, children: [
							container({title: "Item Proficiencies", options: {div: {style: {height: "39vh"}}}, children: []})
						]},
						{tag: "div", style: {width: "45%", left: "28%", position: "absolute", marginBottom: "3.5vh"}, children: [
							container({title: "Equipment", options: {div: {style: {height: "39vh"}}}, children: [
								{tag: "div", style: {margin: "auto", width: "fit-content"}, children: [
									// Equipment
									{tag: "div", 
										attributes: {
											id: "equipment", 
											class: "center-horizontal"
										},
										style: {
											position: "relative",
											display: "grid",
											gridTemplateColumns: "repeat(5, 1fr)",
											gap: 0,
											textAlign: "center",
											placeItems: "center",
											marginTop: "2vh"
										}
									},
									// Switch Weapon Set
									{tag: "button", style: {position: "relative", bottom: "5vh"}, events: {
										click: () => backend(`impersonated().switch_weapon_sets()`)
									}, text: "Switch"}
								]}
							]}),
						]},
						{tag: "div", style: {width: "30%", right: "0", position: "absolute", marginBottom: "3.5vh"}, children: [
							container({title: "Info", id: "inventory-tab-info", options: {div: {style: {height: "39vh"}}}, children: []})
						]},
					]},
					{tag: "div", style: {width: "110%", left: "-4.5%", position: "relative"}, children: [
						container({title: "Backpack", options: {div: {style: {width: "85%"}}}, children: [
							{tag: "div", 
								attributes: {id: "inventory"},
								style: {
									position: "relative",
									width: "fit-content",
									margin: "auto",
									display: "grid",
									gridTemplateColumns: "repeat(13, 1fr)",
									gridRowGap: "0.2vh",
									gap: 0,
									marginTop: "2vh"
								}
							}
						]})
					]}
				])
			
				// Abilities
				document.getElementById("abilities-tab").appendChildren([
					{tag: "div", style: {position: "absolute", left: "-4%", width: "75%"}, children: [
						container({title: "Abilites", id: "abilities-tab-abilities", scroll: true, options: {
							div: {style: {height: "80vh"}},
							content: {style: {padding: "0 2vh", paddingRight: "2.5vh"}}
						}})
					]},
					{tag: "div", style: {position: "absolute", right: "-1%", width: "37%"}, children: [
						container({title: "Resources", id: "abilities-tab-resources", scroll: true, options: {
							div: {style: {height: "80vh"}},
						}})
					]},
				])

				// Journal
				document.getElementById("journal-tab").appendChildren([
					{tag: "div", style: {position: "absolute", left: "0%", width: "37%"}, children: [
						container({title: "Notes", scroll: true, options: {
								div: {style: {height: "80vh"}},
								content: {style: {padding: "0 2vh", paddingLeft: "3vh", paddingRight: "2.5vh"}},
							},
							children: [
								{tag: "div", attributes: {id: "journal-tab-notes-list"}},
								{tag: "button", style: {position: "sticky", bottom: "1vh"}, events: {click: addNote}, text: "Add Note"},
							]
						})
					]},
					{tag: "div", style: {position: "absolute", right: "-4.5%", width: "75%"}, children: [
						container({title: "Details", id: "journal-tab-note", scroll: true, options: {
							div: {style: {height: "80vh"}},
						}})
					]},
				])

				// Spells
				const buttonStyle = {boxShadow: "1px 1px 5px rgba(0,0,0,0.3)", fontSize: "110%", borderColor: "#777"}
				const spellLevelButtons = []
				for (let i = 0; i <= 9; i++) {
					spellLevelButtons.push(
						{tag: "button", text: i, style: buttonStyle, events: {
							click: function () {
								const isActive = this.classList.contains("active")
								const levelButtons = this.parentNode.children
								for (button of levelButtons) {
									button.classList.remove("active")
								}

								const postfix = ["st", "nd", "rd"].length >= i ? ["st", "nd", "rd"][i - 1] || "" : "th"
								const name = i == 0 ? "cantrip" : i + postfix

								if (isActive) {
									this.classList.remove("active")
									this.parentNode.setAttribute("value", "")
								}
								else {
									this.classList.add("active")
									this.parentNode.setAttribute("value", name)
								}

								updateSpellsTab()
							}
						}}
				)}
				document.getElementById("spells-tab").appendChildren([
					{tag: "div", style: {position: "absolute", left: "-4%", width: "75%"}, children: [
						container({title: "Spells", scroll: false, options: {
							div: {style: {height: "80vh"}},
						}, children: [
							{tag: "div", style: {display: "flex", justifyContent: "center", padding: "0.5vh", margin: 0}, children: [
								{tag: "div", attributes: {id: "spells-tab-spells-level", value: ""}, children: spellLevelButtons},
								{tag: "button", text: "M", 
									attributes: {id: "spells-tab-spells-memorized-only", value: "false", class: "tooltip", tooltip: "Show only memorized"}, 
									style: {...buttonStyle, marginLeft: "2vh"},
								events: {
									click: function () {
										const isActive = this.getAttribute("value") == "true"

										// Update Value
										this.setAttribute("value", isActive ? "false" : "true")

										// Update style
										if (isActive) this.classList.remove("active")
										else this.classList.add("active")

										updateSpellsTab()
									}
								}}
							]},
							{tag: "div", attributes: {id: "spells-tab-spells"}, style: {overflow: "scroll", height: "93%", padding: "0 1vh", paddingRight: "1.5vh"}}
						]})
					]},
					{tag: "div", style: {position: "absolute", right: "-1%", width: "37%"}, children: [
						container({title: "Class", scroll: true, options: {
							div: {style: {height: "29.7vh"}},
						}, children: [
							select({id: "spells-tab-class", placeholder: "Class", events: {change: updateSpellsTab}}),
							{tag: "div", attributes: {id: "spells-tab-class-info"}, style: {marginTop: "3vh"}}
						]}),
						container({title: "Spell Slots", scroll: true, options: {
							div: {style: {height: "45vh"}},
						}, children: [
							{tag: "div", attributes: {id: "spells-tab-spell-slots"}, style: {padding: "0"}}
						]})
					]},
				])
			}

			//=====================================================================================================
			// Execution
			//=====================================================================================================

			function updatePage () {
				// Run first time
				closeIfNotImpersonated()
				updateInventoryTab()
				updateCharacterTab()
				updateAbilitiesTab()
				updateSpellsTab()

				// Set update intervals
				setInterval(()=> {
					closeIfNotImpersonated()
					updateInventoryTab()
					updateAbilitiesTab()
					updateSpellsTab()
				}, 500)
				setInterval(() => updateCharacterTab(), 1000)
			}

			window.onload = function () {
				loadPage()
				updatePage()
			}

			//=====================================================================================================
	
		</script>
		']
	</head>
	
	<body>
	</body>
	
	}]