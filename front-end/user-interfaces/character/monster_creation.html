[h,if(!argCount()>0):id = arg(0); id = getImpersonated()]
[h,if(id==""):id = getImpersonated()]

[dialog5("Character", "width=800; height=800; temporary=0; input=1; noframe=0"), code: {
<head>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="style.css@lib:front"></link>
    [r:scriptTag("open")][r:importScript("images.js@lib:front")][r:scriptTag("close")]
    [r:scriptTag("open")][r:importScript("script.js@lib:front")][r:scriptTag("close")]
    [r:scriptTag("open")][r:importScript("components_new.js@lib:front")][r:scriptTag("close")]
    [r:scriptTag("open")][r:importScript("data_description.js@lib:front")][r:scriptTag("close")]

    [r:'
    <style>
        .container {
            margin-bottom: 4vh
        }
    </style>
    <script>

    const monster = {
        size: "Medium",
        health_archetype: "Default",
        challenge_rating: "1/8",
        natural_armor_class: "10",
        initiative_mod: "0",
        speed: "30",
        ability_scores: { strength: 10, dexterity: 10, constitution: 10, intelligence: 10, wisdom: 10, charisma: 10 },
        features: [],
        proficiencies: {"Weapon": 2},

        spellcasting_level: "",
        spellcasting_class: "",
        spells: {},
    }

    async function loadMonster() {
        if (!(await isMonster())) return

        const impersonated = JSON.parse(await backend(`try {
            JSON.stringify({
                name: impersonated().name,
                type: impersonated().type,
                size: impersonated().size,
                race: impersonated().race,
                health_archetype: impersonated().health_archetype,
                challenge_rating: impersonated().challenge_rating,
                natural_armor_class: impersonated().natural_armor_class,
                initiative_mod: impersonated().initiative_mod,
                speed: impersonated().base_speed,
                ability_scores: impersonated().ability_scores,
                features: impersonated().features,
                proficiencies: impersonated().proficiencies,
                spellcasting_level: impersonated().spellcasting_level,
                spellcasting_class: impersonated().spellcasting_class,
                spells: impersonated().spells,
            })
        } catch { "{}" }`))
        for (const key in impersonated) monster[key] = impersonated[key]
    }

    //=====================================================================================================
    // Helper functions
    //=====================================================================================================
    
    async function submit() {
        // Treat Numbers
        const keys = ["max_health", "natural_armor_class", "initiative_mod", "speed", "spellcasting_level"]
        for (const key of keys) monster[key] = Number(monster[key]) || 0
        for (const score in monster.ability_scores) monster.ability_scores[score] = Number(monster.ability_scores[score]) || 10

        // Backend
        const request = (`
            if ("`+(await isMonster())+`" == "false") new Monster(getImpersonated(), true);
            impersonated().create(`+JSON.stringify(monster)+`)
        `)
        
        //console.log(request)
        backend(request)
        openPage("character_sheet.html", "0")
    }

    function cancel() {
        openPage("character_sheet.html", "0")
    }
    
    function stringifyFeatures(features_array) {
        if (!Array.isArray(features_array) || features_array.length === 0)
            return "";

        return [...new Set(features_array)]
            .map(f => f.trim())
            .filter(f => f !== "")
            .join(", ");
    }

    function stringifyProficiencies(proficiencies_obj) {
        if (!proficiencies_obj || typeof proficiencies_obj !== "object")
            return "";

        const parts = [];

        for (const [name, level] of Object.entries(proficiencies_obj)) {
            if (!name.trim()) continue;

            const lvl = Number(level) || 0;
            parts.push(name.trim()+`:`+lvl);
        }

        return parts.join(", ");
    }

    function triggerAllInputFields() {
        for (const elem of document.querySelectorAll("input, select")) {
            elem.dispatchEvent(new Event("input"))
            elem.dispatchEvent(new Event("change"))
        }
    }

    async function isMonster() {
        return "true" == await backend(`try {
            const token = MapTool?.tokens?.getTokenByID(getImpersonated())
            const classes = token.getProperty("class")
            if (classes == null || classes == "[]") {"false"}
            else {
                const parsedClasses = JSON.parse(classes)
                if (parsedClasses[0] == "Monster") {"true"}
                else {"false"}
            }
        } catch {"false"}`)
    }

    function stringifySpellList(spell_array) {
        if (!Array.isArray(spell_array) || spell_array.length === 0)
            return "";

        return [...new Set(spell_array)]
            .map(s => s.trim())
            .filter(s => s !== "")
            .join(", ");
    }

    function stringifyKnownSpells(monster, spellcasting_class) {
        const class_obj = monster?.spells?.[spellcasting_class] || {};
        return stringifySpellList(class_obj.known || []);
    }

    function stringifyAlwaysPreparedSpells(monster, spellcasting_class) {
        const class_obj = monster?.spells?.[spellcasting_class] || {};
        return stringifySpellList(class_obj.always_prepared || []);
    }

    function stringifyInnateSpells(monster, spellcasting_class) {
        const class_obj = monster?.spells?.[spellcasting_class] || {};
        return stringifySpellList(class_obj.innate || []);
    }


    //=====================================================================================================
    // Create Tabs
    //=====================================================================================================

    async function spellcastingTab () {
        const tab = document.getElementById("spellcasting-tab")
        const database = JSON.parse(await backend(`JSON.stringify({
            spells: database.spells.data,
            spells_list: database.get_spells_list()
        })`))
        let spellcasting_class = monster.spellcasting_class || ""

        // Update Attributes
        const updateSpellcastingClass = {input: function (event) {
            monster.spellcasting_class = this.value
            const previous_spells = monster?.spells[spellcasting_class] || {}
            spellcasting_class = monster.spellcasting_class

            monster.spells = {}
            monster.spells[monster.spellcasting_class] = previous_spells
            //console.log(monster)
        }}
        const updateSpellcastingLevel = {input: function (event) {
            monster.spellcasting_level = Number(this.value) || 0
            //console.log(monster)
        }}
        const updateKnown = {input: function (event) {
            const spells = this.value
                .split(", ")
                .map(f => f.trim())
                .filter(f => f !== "");
            monster.spells[monster.spellcasting_class].known = [...new Set(spells)];
            updateSpellsElem()
            //console.log(monster)
        }}
        const updateAlwaysPrepared = {input: function (event) {
            const spells = this.value
                .split(", ")
                .map(f => f.trim())
                .filter(f => f !== "");
            monster.spells[monster.spellcasting_class].always_prepared = [...new Set(spells)];
            updateSpellsElem()
            //console.log(monster)
        }}
        const updateInnate = {input: function (event) {
            const spells = this.value
                .split(", ")
                .map(f => f.trim())
                .filter(f => f !== "");
            monster.spells[monster.spellcasting_class].innate = [...new Set(spells)];
            updateSpellsElem()
            //console.log(monster)
        }}

        // Update Elements
        function updateSpellsElem() {
            const elem = document.getElementById("spells")
            elem.clearChildren()

            // Spell List
            const class_spells = monster.spells?.[spellcasting_class] || {}
            const selected_spells = [
                ...(class_spells?.known || []), 
                ...(class_spells?.always_prepared || []),
                ...(class_spells?.innate || [])
            ]
            const ordered_spells = database.spells_list.filter(spell => selected_spells.includes(spell))

            let previous_level = undefined
            for (const name of ordered_spells) {
                const spell = database.spells[name]
                const spell_image = spell.image || spell_school_images[spell.school]

                // Conditions
                const spellIsMemorized = class_spells.memorized?.includes(spell.name)
                const spellIsAlwaysPrepared = class_spells.always_prepared?.includes(spell.name)
                const spellIsInnate = class_spells.innate?.includes(spell.name)
                const spellIsCantrip = spell.level == "cantrip"
                
                // Action type
                let action_type
                if (spell.cast_time == -1) action_type = "Bonus Action"
                else if (spell.cast_time == -2) action_type = "Reaction"
                else if (spell.cast_time >= 0) action_type =  "Action"

                // Accent Color
                let accentColor = ""
                if (spellIsInnate) accentColor = "#ca2"
                else if (spellIsAlwaysPrepared) accentColor = "#aaa"

                // Click Spell
                function clickSpell (event) {
                    modal({parent: tab, children: [
                        data_description.spell({spell: spell})
                    ]})
                }

                // Add spacing between levels
                if (previous_level != spell.level) {
                    elem.appendChild({tag: "div", style: {margin: "1.3vh", marginTop: "2vh", padding: 0, fontWeight: "bold"}, text: spell.level == "cantrip" ? "Cantrips" : spell.level + " Level Spells"})
                    previous_level = spell.level
                }

                // Add element
                elem.appendChild(
                    {tag: "div", 
                        attributes: {class: "collapsible-div"}, 
                        style: {
                            display: "flex", gap: "1vh", padding: "0.5vh", marginTop: "1vh",
                            borderColor: accentColor,
                            opacity: 1
                        },
                        events: {mousedown: clickSpell},
                        children: [
                            {tag: "img", attributes: {src: spell_image}},
                            {tag: "span", text: name},
                            {tag: "span", style: {position: "absolute", right: "0.5vh"}, text: action_type},
                        ]
                    }
                )
            }
            
            // Hide Show block
            if (elem.children.length > 0) elem.parentElement.classList.remove("hidden")
            else elem.parentElement.classList.add("hidden")
        }

        // Content
        const containerOptions = {div: {attributes: {class: "hidden"}}, content: {style: {maxHeight: "80vh"}}}
        tab.appendChildren([
            {tag: "div", style: {position: "absolute", left: "0", width: "50%"}, children: [
                // Details
                container({title: "Details", children: [
                    // Class
                    input({id: "spellcasting_class", placeholder: "Class", options: {
                        input: {attributes: {value: spellcasting_class}, events: updateSpellcastingClass}
                    }}),

                    // Spellcasting Level
                    input({id: "spellcasting_level", placeholder: "Spellcasting Level", options: {
                        input: {attributes: {value: monster.spellcasting_level || ""}, events: updateSpellcastingLevel}
                    }}),
                ]}),

                // Spell List
                container({title: "Spell List", children: [
                    // Known Spells
                    input({id: "known", placeholder: "Known Spells", options: {
                        input: {attributes: {value: stringifyKnownSpells(monster, spellcasting_class) || ""}, events: updateKnown}
                    }}),

                    // Always Prepared Spells
                    input({id: "always_prepared", placeholder: "Always Prepared Spells", options: {
                        input: {attributes: {value: stringifyAlwaysPreparedSpells(monster, spellcasting_class) || ""}, events: updateAlwaysPrepared}
                    }}),

                    // Innate Spells
                    input({id: "innate", placeholder: "Innate Spells", options: {
                        input: {attributes: {value: stringifyInnateSpells(monster, spellcasting_class) || ""}, events: updateInnate}
                    }}),
                ]})
            ]},
            {tag : "div", style: {position: "absolute", right: 0, width: "50%"}, children: [
                container({id: "spells", scroll: true, title: "Spells", options: containerOptions}),
            ]},
            {tag: "button", text: "Submit", attributes: {class: "bottom right page-turner"}, 
                events: {click: submit}
            },
            {tag: "button", text: "Cancel", attributes: {class: "bottom left page-turner"}, 
                events: {click: cancel}
            }
        ])
    }

    async function mainTab() {
        const tab = document.getElementById("main-tab")
        const database = JSON.parse(await backend(`JSON.stringify({
            features: database.features.data,
            proficiencies: database.proficiencies.data,
        })`))
        const health_archetype_options = [
            "Default", "Mage", "Soldier", "Brute"
        ]
        const type_options = [
            "Aberration", "Beast", "Celestial", 
            "Construct", "Dragon", "Elemental", 
            "Fey", "Fiend", "Giant", 
            "Humanoid", "Monstrosity", "Ooze",
            "Plant", "Undead"
        ]
        const size_options = [
            "Fine", "Diminutive", "Tiny", 
            "Small", "Medium", "Large", 
            "Huge", "Gargantuan", "Colossal"
        ]
        
        // Elements
        const score = (attribute) => {
            const title = attribute.substring(0, 3).toUpperCase()
            const updateAbilityScore = {input: function (event) {
                monster.ability_scores[this.id] = this.value
                //console.log(monster)
            }}

            return input({id: attribute, placeholder: title, options: {
                div: {style: {width: "10%", fontSize: "110%", marginRight: "1.5vh"}},
                input: {attributes: {value: monster.ability_scores[attribute] || ""}, events: updateAbilityScore, style: {textAlign: "center"}}
            }})
        }
        const abilityScores = [score("strength"), score("dexterity"), score("constitution"), score("intelligence"), score("wisdom"), score("charisma")]
        const creatureTypeSelect = select({
            id: "type",
            placeholder: "Type",
            children: type_options.map(type => ({
                tag: "option",
                attributes: { value: type },
                text: type
            })),
            options: {
                div: {style: {width: "24%", marginRight: "1%"}},
                input: {events: {input: function (event) {
                    monster[this.id] = this.value
                    //console.log(monster)
            }}}} 
        });
        creatureTypeSelect.children[0].value = monster.type ?? "";
        const sizeSelect = select({
            id: "size",
            placeholder: "Size",
            children: size_options.map(type => ({
                tag: "option",
                attributes: { value: type },
                text: type
            })),
            options: {
                div: {style: {width: "24%", marginRight: "0%"}},
                input: {events: {input: function (event) {
                    monster[this.id] = this.value
                    //console.log(monster)
            }}}} 
        });
        sizeSelect.children[0].value = monster.size ?? "";
        const healthArchetypeSelect = select({
            id: "health_archetype",
            placeholder: "Health Archetype",
            children: health_archetype_options.map(type => ({
                tag: "option",
                attributes: { value: type },
                text: type
            })),
            options: {
                div: {style: {width: "49%", marginRight: "1%"}},
                input: {events: {input: function (event) {
                    monster[this.id] = this.value
                    //console.log(monster)
            }}}} 
        });
        healthArchetypeSelect.children[0].value = monster.health_archetype ?? "Default";

        // Update Elements
        function updateFeaturesElem() {
            const elem = document.getElementById("features")
            elem.clearChildren()

            for (const name of monster.features) {
                if (!database.features[name]) continue
                const feature = database.features[name]

                const { type, subtype, level, description } = feature
                const image = class_images[subtype] || feature_images[type] || ""

                collapsible({parent: elem,
                    options: {
                        button: {style: {display: "flex", gap: "1vh", padding: "0.5vh", margin: "0 1vh"}, events: {
                            mousedown: () => modal({parent: tab, children: [
                                data_description.feature({feature: feature})
                            ]})
                        }},
                        content: {style: {marginRight: "1.3vh", marginLeft: "1.3vh"}}
                    },
                    button_children: [
                        {tag: "img", attributes: {src: image}},
                        {tag: "span", text: name},
                        {tag: "span", style: {position: "absolute", right: "0.5vh"}, text: subtype || capitalize(type)}
                    ],
                })
            }

            // Hide Show feature block
            if (elem.children.length > 0) elem.parentElement.classList.remove("hidden")
            else elem.parentElement.classList.add("hidden")
        }
        function updateProficienciesElem() {
            const elem = document.getElementById("proficiencies")
            elem.clearChildren()

            for (const name in monster.proficiencies) {
                if (!database.proficiencies[name]) continue
                
                const level = monster.proficiencies[name]
                const proficiency = database.proficiencies[name]

                const type = proficiency?.type || "None"
                const description = proficiency?.description?.slice(0, level + 1) || ""
                const image = proficiency_images[type] || ""
                const level_title = [" Proficiency", " Expertise", " Mastery", " Grandmastery"][level]

                collapsible({parent: elem,
                    options: {
                        button: {style: {display: "flex", gap: "1vh", padding: "0.5vh", margin: "0 1vh"}, events: {
                            mousedown: () => modal({parent: tab, children: [
                                data_description.proficiency({proficiency: proficiency, level: level})
                            ]})
                        }},
                        content: {style: {marginRight: "1.3vh", marginLeft: "1.3vh"}}
                    },
                    button_children: [
                        {tag: "img", attributes: {src: image}},
                        {tag: "span", text: name + (type == "language" ? "" : level_title)},
                        {tag: "span", style: {position: "absolute", right: "0.5vh"}, text: capitalize(type)}
                    ],
                })
            }

            // Hide Show feature block
            if (elem.children.length > 0) elem.parentElement.classList.remove("hidden")
            else elem.parentElement.classList.add("hidden")
        }

        // Update attributes
        const updateAttribute = {input: function (event) {
            monster[this.id] = this.value
            //console.log(monster)
        }}
        const updateFeatures = {input: function (event) {
            const features = this.value
                .split(", ")
                .map(f => f.trim())
                .filter(f => f !== "");
            monster.features = [...new Set(features)];
            updateFeaturesElem()
            //console.log(monster)
        }}
        const updateProficiencies = {input: function (event) {
            const proficiencies = {};

            // Split into groups like "stealth:2"
            for (const prof_group of this.value.split(",")) {

                // Clean whitespace
                const cleaned = prof_group.trim();
                if (!cleaned) continue;  // skip empty groups

                const [proficiency_raw, level_raw] = cleaned.split(":");

                // Validate proficiency name
                const proficiency = proficiency_raw?.trim();
                if (!proficiency) continue;

                // Convert level to number (default 0)
                const level = Number(level_raw?.trim()) || 0;

                // Overwriting removes duplicates automatically
                proficiencies[proficiency] = level;
            }

            monster.proficiencies = proficiencies;
            updateProficienciesElem();
            //console.log(monster);
        }};

        // Content
        const containerOptions = {div: {attributes: {class: "hidden"}}, content: {style: {maxHeight: "20vh"}}}
        tab.appendChildren([
            {tag: "div", style: {position: "absolute", left: "0", width: "50%"}, children: [
                // Lore
                container({title: "Lore", children: [
                    // Name
                    input({id: "name", placeholder: "Name", options: {
                        input: {attributes: {value: monster.name || ""}, events: updateAttribute}
                    }}),

                    // Type
                    creatureTypeSelect,

                    // Race
                    input({id: "race", placeholder: "Race", options: {
                        div: {style: {width: "49%", marginRight: "1%"}},
                        input: {attributes: {value: monster.race || ""}, events: updateAttribute}
                    }}),

                    sizeSelect,

                    // Challenge Rating
                    input({id: "challenge_rating", placeholder: "Challenge Rating", options: {
                        div: {style: {width: "100%", marginRight: "0%"}},
                        input: {attributes: {value: monster.challenge_rating || ""}, events: updateAttribute}
                    }}),
                ]}),

                // Ability Scores
                container({title: "Ability Scores", children: abilityScores}),

                // Combat Stats
                container({title: "Stats", children: [
                    // Health Archetype
                    healthArchetypeSelect,

                    // Armor Class
                    input({id: "natural_armor_class", placeholder: "Natural Armor Class", options: {
                        div: {style: {width: "49%", marginRight: "0%"}},
                        input: {attributes: {value: monster.natural_armor_class ?? ""}, events: updateAttribute}
                    }}),

                    // Initiative Modifier
                    input({id: "initiative_mod", placeholder: "Initiative Modifier", options: {
                        div: {style: {width: "49%", marginRight: "2%"}},
                        input: {attributes: {value: monster.initiative_mod ?? ""}, events: updateAttribute}
                    }}),

                    // Speed
                    input({id: "speed", placeholder: "Speed", options: {
                        div: {style: {width: "49%", marginRight: "0%"}},
                        input: {attributes: {value: monster.speed || ""}, events: updateAttribute}
                    }}),
                ]}),

            ]},
            {tag : "div", style: {position: "absolute", right: 0, width: "50%"}, children: [
                container({title: "Special", children: [
                    // Features
                    input({placeholder: `Features (proficiency, proficiency)`, options: {
                        input: {attributes: {value: stringifyFeatures(monster.features)}, events: updateFeatures}
                    }}),

                    // Proficiencies
                    input({placeholder: `Proficiencies (proficiency:level, proficiency:level)`, options: {
                        input: {attributes: {value: stringifyProficiencies(monster.proficiencies)}, events: updateProficiencies}
                    }}),
                ]}),

                container({id: "features", scroll: true, title: "Features", options: containerOptions}),
                container({id: "proficiencies", scroll: true, title: "Proficiencies", options: containerOptions})
            ]},
            {tag: "button", text: "Submit", attributes: {class: "bottom right page-turner"}, 
                events: {click: submit}
            },
            {tag: "button", text: "Cancel", attributes: {class: "bottom left page-turner"}, 
                events: {click: cancel}
            }
        ])
    }

    async function loadPage() {
        create_tabs({content: ["main", "spellcasting"], parent: document.body})
        await loadMonster()
        await mainTab()
        await spellcastingTab()
        triggerAllInputFields()
    }
    
    //=====================================================================================================
    // Execution
    //=====================================================================================================

    window.onload = function () {
        loadPage()
    }

    //=====================================================================================================

    </script>
    ']
</head>

<body>
</body>

}]