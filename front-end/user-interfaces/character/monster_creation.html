[h,if(!argCount()>0):id = arg(0); id = getImpersonated()]
[h,if(id==""):id = getImpersonated()]

[dialog5("Character", "width=800; height=800; temporary=0; input=1; noframe=0"), code: {
<head>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="style.css@lib:front"></link>
    [r:scriptTag("open")][r:importScript("images.js@lib:front")][r:scriptTag("close")]
    [r:scriptTag("open")][r:importScript("script.js@lib:front")][r:scriptTag("close")]
    [r:scriptTag("open")][r:importScript("components_new.js@lib:front")][r:scriptTag("close")]
    [r:scriptTag("open")][r:importScript("data_description.js@lib:front")][r:scriptTag("close")]

    [r:'
    <style>
        .container {
            margin-bottom: 4vh
        }
    </style>
    <script>

    const monster = {
        max_health: 10,
        challenge_rating: "1/8",
        armor_class: "10",
        initiative_mod: "0",
        speed: "30",
        ability_scores: { strength: 10, dexterity: 10, constitution: 10, intelligence: 10, wisdom: 10, charisma: 10 },
        features: [],
        proficiencies: {"Weapon": 2},

        spellcasting_level: 0,
        spellcasting_class: "",
        spells: {},
    }

    async function loadMonster() {
        if (!(await isMonster())) return

        const impersonated = JSON.parse(await backend(`try {
            JSON.stringify({
                name: impersonated().name,
                type: impersonated().type,
                race: impersonated().race,
                max_health: impersonated().max_health,
                challenge_rating: impersonated().challenge_rating,
                armor_class: impersonated().armor_class,
                initiative_mod: impersonated().initiative_mod,
                speed: impersonated().speed,
                ability_scores: impersonated().ability_scores,
                features: impersonated().features,
                proficiencies: impersonated().proficiencies,
                spellcasting_level: impersonated().spellcasting_level,
                spellcasting_class: impersonated().spellcasting_class,
                spells: impersonated().spells,
            })
        } catch { "{}" }`))
        for (const key in impersonated) monster[key] = impersonated[key]
    }

    //=====================================================================================================
    // Helper functions
    //=====================================================================================================
    
    async function submit() {
        // Treat Numbers
        const keys = ["max_health", "armor_class", "initiative_mod", "speed"]
        for (const key of keys) monster[key] = Number(monster[key]) || 0
        for (const score in monster.ability_scores) monster.ability_scores[score] = Number(monster.ability_scores[score]) || 10

        // Backend
        const request = (`
            if ("`+(await isMonster())+`" == "false") new Monster(getImpersonated(), true);
            impersonated().create(`+JSON.stringify(monster)+`)
        `)
        //console.log(request)
        backend(request)
        openPage("character_sheet.html", "0")
    }

    function cancel() {
        openPage("character_sheet.html", "0")
    }
    
    function stringifyFeatures(features_array) {
        if (!Array.isArray(features_array) || features_array.length === 0)
            return "";

        return [...new Set(features_array)]
            .map(f => f.trim())
            .filter(f => f !== "")
            .join(", ");
    }

    function stringifyProficiencies(proficiencies_obj) {
        if (!proficiencies_obj || typeof proficiencies_obj !== "object")
            return "";

        const parts = [];

        for (const [name, level] of Object.entries(proficiencies_obj)) {
            if (!name.trim()) continue;

            const lvl = Number(level) || 0;
            parts.push(name.trim()+`:`+lvl);
        }

        return parts.join(", ");
    }

    function triggerAllInputFields() {
        for (const elem of document.querySelectorAll("input, select")) {
            elem.dispatchEvent(new Event("input"))
            elem.dispatchEvent(new Event("change"))
        }
    }

    async function isMonster() {
        return "true" == await backend(`try {
            const token = MapTool?.tokens?.getTokenByID(getImpersonated())
            const classes = token.getProperty("class")
            if (classes == null || classes == "[]") {"false"}
            else {
                const parsedClasses = JSON.parse(classes)
                if (parsedClasses[0] == "Monster") {"true"}
                else {"false"}
            }
        } catch {"false"}`)
    }

    //=====================================================================================================
    // Create Tabs
    //=====================================================================================================

    async function spellcastingTab () {
        const tab = document.getElementById("spellcasting-tab")
        const database = JSON.parse(await backend(`JSON.stringify({
            spells: database.spells.data,
        })`))
        let spellcasting_class = monster.spellcasting_class || ""

        // Update Attributes
        const updateSpellcastingClass = {input: function (event) {
            monster.spellcasting_class = this.value
            const previous_spells = monster?.spells[spellcasting_class] || {}
            spellcasting_class = monster.spellcasting_class

            monster.spells = {}
            monster.spells[monster.spellcasting_class] = previous_spells
            console.log(monster)
        }}
        const updateSpellcastingLevel = {input: function (event) {
            monster.level = Number(this.value) || 0
            console.log(monster)
        }}
        const updateKnown = {input: function (event) {
            const spells = this.value
                .split(", ")
                .map(f => f.trim())
                .filter(f => f !== "");
            monster.spells[monster.spellcasting_class].known = [...new Set(spells)];
            console.log(monster)
        }}
        const updateAlwaysPrepared = {input: function (event) {
            const spells = this.value
                .split(", ")
                .map(f => f.trim())
                .filter(f => f !== "");
            monster.spells[monster.spellcasting_class].always_prepared = [...new Set(spells)];
            console.log(monster)
        }}
        const updateInnate = {input: function (event) {
            const spells = this.value
                .split(", ")
                .map(f => f.trim())
                .filter(f => f !== "");
            monster.spells[monster.spellcasting_class].innate = [...new Set(spells)];
            console.log(monster)
        }}

        // Content
        const containerOptions = {div: {attributes: {class: "hidden"}}, content: {style: {maxHeight: "40vh"}}}
        tab.appendChildren([
            {tag: "div", style: {position: "absolute", left: "0", width: "50%"}, children: [
                // Details
                container({title: "Details", children: [
                    // Class
                    input({id: "spellcasting_class", placeholder: "Class", options: {
                        input: {attributes: {value: spellcasting_class}, events: updateSpellcastingClass}
                    }}),

                    // Spellcasting Level
                    input({id: "spellcasting_level", placeholder: "Spellcasting Level", options: {
                        input: {attributes: {value: monster.spellcasting_level || "0"}, events: updateSpellcastingLevel}
                    }}),
                ]}),

                // Spell List
                container({title: "Spell List", children: [
                    // Known Spells
                    input({id: "known", placeholder: "Known Spells", options: {
                        input: {attributes: {value: ""}, events: updateKnown}
                    }}),

                    // Always Prepared Spells
                    input({id: "always_prepared", placeholder: "Always Prepared Spells", options: {
                        input: {attributes: {value: ""}, events: updateAlwaysPrepared}
                    }}),

                    // Innate Spells
                    input({id: "innate", placeholder: "Innate Spells", options: {
                        input: {attributes: {value: ""}, events: updateInnate}
                    }}),
                ]})
            ]},
            {tag : "div", style: {position: "absolute", right: 0, width: "50%"}, children: [
                container({id: "spells", scroll: true, title: "Spells", options: containerOptions}),
            ]},
            {tag: "button", text: "Submit", attributes: {class: "bottom right page-turner"}, 
                events: {click: submit}
            },
            {tag: "button", text: "Cancel", attributes: {class: "bottom left page-turner"}, 
                events: {click: cancel}
            }
        ])
    }

    async function mainTab() {
        const tab = document.getElementById("main-tab")
        const database = JSON.parse(await backend(`JSON.stringify({
            features: database.features.data,
            proficiencies: database.proficiencies.data,
        })`))
        const type_options = [
            "Aberration", "Beast", "Celestial", 
            "Construct", "Dragon", "Elemental", 
            "Fey", "Fiend", "Giant", 
            "Humanoid", "Monstrosity", "Ooze",
            "Plant", "Undead"
        ]
        
        // Elements
        const score = (attribute) => {
            const title = attribute.substring(0, 3).toUpperCase()
            const updateAbilityScore = {input: function (event) {
                monster.ability_scores[this.id] = this.value
                //console.log(monster)
            }}

            return input({id: attribute, placeholder: title, options: {
                div: {style: {width: "10%", fontSize: "110%", marginRight: "1.5vh"}},
                input: {attributes: {value: monster.ability_scores[attribute] || ""}, events: updateAbilityScore, style: {textAlign: "center"}}
            }})
        }
        const abilityScores = [score("strength"), score("dexterity"), score("constitution"), score("intelligence"), score("wisdom"), score("charisma")]
        const creatureTypeSelect = select({
            id: "type",
            placeholder: "Type",
            children: type_options.map(type => ({
                tag: "option",
                attributes: { value: type },
                text: type
            })),
            options: {input: {events: {input: function (event) {
                monster[this.id] = this.value
                //console.log(monster)
            }}}} 
        });
        creatureTypeSelect.children[0].value = monster.type ?? "";

        // Update Elements
        function updateFeaturesElem() {
            const featureElement = document.getElementById("features")
            featureElement.clearChildren()

            for (const name of monster.features) {
                if (!database.features[name]) continue
                const feature = database.features[name]

                const { type, subtype, level, description } = feature
                const image = class_images[subtype] || feature_images[type] || ""

                collapsible({parent: featureElement,
                    options: {
                        button: {style: {display: "flex", gap: "1vh", padding: "0.5vh", margin: "0 1vh"}, events: {
                            mousedown: () => modal({parent: tab, children: [
                                data_description.feature({feature: feature})
                            ]})
                        }},
                        content: {style: {marginRight: "1.3vh", marginLeft: "1.3vh"}}
                    },
                    button_children: [
                        {tag: "img", attributes: {src: image}},
                        {tag: "span", text: name},
                        {tag: "span", style: {position: "absolute", right: "0.5vh"}, text: subtype || capitalize(type)}
                    ],
                })
            }

            // Hide Show feature block
            if (featureElement.children.length > 0) featureElement.parentElement.classList.remove("hidden")
            else featureElement.parentElement.classList.add("hidden")
        }
        function updateProficienciesElem() {
            const profElement = document.getElementById("proficiencies")
            profElement.clearChildren()

            for (const name in monster.proficiencies) {
                if (!database.proficiencies[name]) continue
                
                const level = monster.proficiencies[name]
                const proficiency = database.proficiencies[name]

                const type = proficiency?.type || "None"
                const description = proficiency?.description?.slice(0, level + 1) || ""
                const image = proficiency_images[type] || ""
                const level_title = [" Proficiency", " Expertise", " Mastery", " Grandmastery"][level]

                collapsible({parent: profElement,
                    options: {
                        button: {style: {display: "flex", gap: "1vh", padding: "0.5vh", margin: "0 1vh"}, events: {
                            mousedown: () => modal({parent: tab, children: [
                                data_description.proficiency({proficiency: proficiency, level: level})
                            ]})
                        }},
                        content: {style: {marginRight: "1.3vh", marginLeft: "1.3vh"}}
                    },
                    button_children: [
                        {tag: "img", attributes: {src: image}},
                        {tag: "span", text: name + (type == "language" ? "" : level_title)},
                        {tag: "span", style: {position: "absolute", right: "0.5vh"}, text: capitalize(type)}
                    ],
                })
            }

            // Hide Show feature block
            if (profElement.children.length > 0) profElement.parentElement.classList.remove("hidden")
            else profElement.parentElement.classList.add("hidden")
        }

        // Update attributes
        const updateAttribute = {input: function (event) {
            monster[this.id] = this.value
            //console.log(monster)
        }}
        const updateFeatures = {input: function (event) {
            const features = this.value
                .split(", ")
                .map(f => f.trim())
                .filter(f => f !== "");
            monster.features = [...new Set(features)];
            updateFeaturesElem()
            //console.log(monster)
        }}
        const updateProficiencies = {input: function (event) {
            const proficiencies = {};

            // Split into groups like "stealth:2"
            for (const prof_group of this.value.split(",")) {

                // Clean whitespace
                const cleaned = prof_group.trim();
                if (!cleaned) continue;  // skip empty groups

                const [proficiency_raw, level_raw] = cleaned.split(":");

                // Validate proficiency name
                const proficiency = proficiency_raw?.trim();
                if (!proficiency) continue;

                // Convert level to number (default 0)
                const level = Number(level_raw?.trim()) || 0;

                // Overwriting removes duplicates automatically
                proficiencies[proficiency] = level;
            }

            monster.proficiencies = proficiencies;
            updateProficienciesElem();
            //console.log(monster);
        }};

        // Content
        const containerOptions = {div: {attributes: {class: "hidden"}}, content: {style: {maxHeight: "20vh"}}}
        tab.appendChildren([
            {tag: "div", style: {position: "absolute", left: "0", width: "50%"}, children: [
                // Lore
                container({title: "Lore", children: [
                    // Name
                    input({id: "name", placeholder: "Name", options: {
                        input: {attributes: {value: monster.name || ""}, events: updateAttribute}
                    }}),

                    // Type
                    creatureTypeSelect,

                    // Race
                    input({id: "race", placeholder: "Race", options: {
                        input: {attributes: {value: monster.race || ""}, events: updateAttribute}
                    }})
                ]}),

                // Ability Scores
                container({title: "Ability Scores", children: abilityScores}),

                // Combat Stats
                container({title: "Stats", children: [
                    // Max Health
                    input({id: "max_health", placeholder: "Max Health", options: {
                        input: {attributes: {value: monster.max_health || ""}, events: updateAttribute}
                    }}),

                    // Challenge Rating
                    input({id: "challenge_rating", placeholder: "Challenge Rating", options: {
                        input: {attributes: {value: monster.challenge_rating || ""}, events: updateAttribute}
                    }}),

                    // Armor Class
                    input({id: "armor_class", placeholder: "Natural Armor Class", options: {
                        input: {attributes: {value: monster.armor_class || ""}, events: updateAttribute}
                    }}),

                    // Initiative Modifier
                    input({id: "initiative_mod", placeholder: "Initiative Modifier", options: {
                        input: {attributes: {value: monster.initiative_mod || ""}, events: updateAttribute}
                    }}),

                    // Speed
                    input({id: "speed", placeholder: "Speed", options: {
                        input: {attributes: {value: monster.speed || ""}, events: updateAttribute}
                    }}),
                ]}),

            ]},
            {tag : "div", style: {position: "absolute", right: 0, width: "50%"}, children: [
                container({title: "Special", children: [
                    // Features
                    input({placeholder: `Features (proficiency, proficiency)`, options: {
                        input: {attributes: {value: stringifyFeatures(monster.features)}, events: updateFeatures}
                    }}),

                    // Proficiencies
                    input({placeholder: `Proficiencies (proficiency:level, proficiency:level)`, options: {
                        input: {attributes: {value: stringifyProficiencies(monster.proficiencies)}, events: updateProficiencies}
                    }}),
                ]}),

                container({id: "features", scroll: true, title: "Features", options: containerOptions}),
                container({id: "proficiencies", scroll: true, title: "Proficiencies", options: containerOptions})
            ]},
            {tag: "button", text: "Submit", attributes: {class: "bottom right page-turner"}, 
                events: {click: submit}
            },
            {tag: "button", text: "Cancel", attributes: {class: "bottom left page-turner"}, 
                events: {click: cancel}
            }
        ])
    }

    async function loadPage() {
        create_tabs({content: ["main", "spellcasting"], parent: document.body})
        await loadMonster()
        await mainTab()
        await spellcastingTab()
        triggerAllInputFields()
    }
    
    //=====================================================================================================
    // Execution
    //=====================================================================================================

    window.onload = function () {
        loadPage()
    }

    //=====================================================================================================

    </script>
    ']
</head>

<body>
</body>

}]