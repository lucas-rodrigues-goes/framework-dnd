[h,if(!argCount()>0):id = arg(0); id = getImpersonated()]
[h,if(id==""):id = getImpersonated()]

[dialog5("Character", "width=800; height=800; temporary=0; input=1; noframe=0"), code: {
<head>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="style.css@lib:front"></link>
    [r:scriptTag("open")][r:importScript("images.js@lib:front")][r:scriptTag("close")]
    [r:scriptTag("open")][r:importScript("script.js@lib:front")][r:scriptTag("close")]
    [r:scriptTag("open")][r:importScript("components_new.js@lib:front")][r:scriptTag("close")]
    [r:scriptTag("open")][r:importScript("data_description.js@lib:front")][r:scriptTag("close")]

    [r:'
    <style>
        .container {
            margin-bottom: 4vh
        }
    </style>
    <script>

    const monster = {
        size: "Medium",
        health_archetype: "Default",
        challenge_rating: "1/8",
        natural_armor_class: "10",
        initiative_mod: "0",
        speed: "30",
        ability_scores: { strength: 10, dexterity: 10, constitution: 10, intelligence: 10, wisdom: 10, charisma: 10 },
        features: [],
        proficiencies: {"Weapon": 2},

        spellcasting_level: "",
        spells: {
            Monster: {
                known: [],
                innate: []
            }
        },

        abilities: {}
    }

    async function loadMonster() {
        if (!(await isMonster())) return

        const impersonated = JSON.parse(await backend(`try {
            JSON.stringify({
                name: impersonated().name,
                type: impersonated().type,
                size: impersonated().size,
                race: impersonated().race,
                health_archetype: impersonated().health_archetype,
                challenge_rating: impersonated().challenge_rating,
                natural_armor_class: impersonated().natural_armor_class,
                initiative_mod: impersonated().initiative_mod,
                speed: impersonated().base_speed,
                ability_scores: impersonated().ability_scores,
                features: impersonated().features,
                proficiencies: impersonated().proficiencies,
                spellcasting_level: impersonated().spellcasting_level,
                spells: impersonated().spells,
                abilities: impersonated().custom_abilities || {},
            })
        } catch { "{}" }`))
        for (const key in impersonated) monster[key] = impersonated[key]

        if (!monster.spells) monster.spells = {}
        if (!monster.spells.Monster) monster.spells.Monster = { known: [], innate: [] }
        if (!monster.spells.Monster.known) monster.spells.Monster.known = []
        if (!monster.spells.Monster.innate) monster.spells.Monster.innate = []
    }

    //=====================================================================================================
    // Helper functions
    //=====================================================================================================
    
    async function submit() {
        // Treat Numbers
        const keys = ["max_health", "natural_armor_class", "initiative_mod", "speed", "spellcasting_level"]
        for (const key of keys) monster[key] = Number(monster[key]) || 0
        for (const score in monster.ability_scores) monster.ability_scores[score] = Number(monster.ability_scores[score]) || 10

        // Backend
        const request = (`
            if ("`+(await isMonster())+`" == "false") new Monster(getImpersonated(), true);
            impersonated().create(`+JSON.stringify(monster)+`)
        `)
        
        //console.log(request)
        backend(request)
        openPage("character_sheet.html", "0")
    }

    function cancel() {
        openPage("character_sheet.html", "0")
    }
    
    function stringifyFeatures(features_array) {
        if (!Array.isArray(features_array) || features_array.length === 0)
            return "";

        return [...new Set(features_array)]
            .map(f => f.trim())
            .filter(f => f !== "")
            .join(", ");
    }

    function stringifyProficiencies(proficiencies_obj) {
        if (!proficiencies_obj || typeof proficiencies_obj !== "object")
            return "";

        const parts = [];

        for (const [name, level] of Object.entries(proficiencies_obj)) {
            if (!name.trim()) continue;

            const lvl = Number(level) || 0;
            parts.push(name.trim()+`:`+lvl);
        }

        return parts.join(", ");
    }

    function triggerAllInputFields() {
        for (const elem of document.querySelectorAll("input, select")) {
            elem.dispatchEvent(new Event("input"))
            elem.dispatchEvent(new Event("change"))
        }
    }

    async function isMonster() {
        return "true" == await backend(`try {
            const token = MapTool?.tokens?.getTokenByID(getImpersonated())
            const classes = token.getProperty("class")
            if (classes == null || classes == "[]") {"false"}
            else {
                const parsedClasses = JSON.parse(classes)
                if (parsedClasses[0] == "Monster") {"true"}
                else {"false"}
            }
        } catch {"false"}`)
    }

    function stringifySpellList(spell_array) {
        if (!Array.isArray(spell_array) || spell_array.length === 0)
            return "";

        return [...new Set(spell_array)]
            .map(s => s.trim())
            .filter(s => s !== "")
            .join(", ");
    }

    function stringifyKnownSpells(monster) {
        const class_obj = monster?.spells?.Monster || {};
        return stringifySpellList(class_obj.known || []);
    }

    function stringifyInnateSpells(monster) {
        const class_obj = monster?.spells?.Monster || {};
        return stringifySpellList(class_obj.innate || []);
    }


    //=====================================================================================================
    // Create Tabs
    //=====================================================================================================

    async function mainTab() {
        const tab = document.getElementById("main-tab")
        const database = JSON.parse(await backend(`JSON.stringify({
            features: database.features.data,
            proficiencies: database.proficiencies.data,
        })`))
        const health_archetype_options = [
            "Default", "Mage", "Soldier", "Brute"
        ]
        const type_options = [
            "Aberration", "Beast", "Celestial", 
            "Construct", "Dragon", "Elemental", 
            "Fey", "Fiend", "Giant", 
            "Humanoid", "Monstrosity", "Ooze",
            "Plant", "Undead"
        ]
        const size_options = [
            "Fine", "Diminutive", "Tiny", 
            "Small", "Medium", "Large", 
            "Huge", "Gargantuan", "Colossal"
        ]
        
        // Elements
        const score = (attribute) => {
            const title = attribute.substring(0, 3).toUpperCase()
            const updateAbilityScore = {input: function (event) {
                monster.ability_scores[this.id] = this.value
                //console.log(monster)
            }}

            return input({id: attribute, placeholder: title, options: {
                div: {style: {width: "10%", fontSize: "110%", marginRight: "1.5vh"}},
                input: {attributes: {value: monster.ability_scores[attribute] || ""}, events: updateAbilityScore, style: {textAlign: "center"}}
            }})
        }
        const abilityScores = [score("strength"), score("dexterity"), score("constitution"), score("intelligence"), score("wisdom"), score("charisma")]
        const creatureTypeSelect = select({
            id: "type",
            placeholder: "Type",
            children: type_options.map(type => ({
                tag: "option",
                attributes: { value: type },
                text: type
            })),
            options: {
                div: {style: {width: "24%", marginRight: "1%"}},
                input: {events: {input: function (event) {
                    monster[this.id] = this.value
                    //console.log(monster)
            }}}} 
        });
        creatureTypeSelect.children[0].value = monster.type ?? "";
        const sizeSelect = select({
            id: "size",
            placeholder: "Size",
            children: size_options.map(type => ({
                tag: "option",
                attributes: { value: type },
                text: type
            })),
            options: {
                div: {style: {width: "24%", marginRight: "0%"}},
                input: {events: {input: function (event) {
                    monster[this.id] = this.value
                    //console.log(monster)
            }}}} 
        });
        sizeSelect.children[0].value = monster.size ?? "";
        const healthArchetypeSelect = select({
            id: "health_archetype",
            placeholder: "Health Archetype",
            children: health_archetype_options.map(type => ({
                tag: "option",
                attributes: { value: type },
                text: type
            })),
            options: {
                div: {style: {width: "49%", marginRight: "1%"}},
                input: {events: {input: function (event) {
                    monster[this.id] = this.value
                    //console.log(monster)
            }}}} 
        });
        healthArchetypeSelect.children[0].value = monster.health_archetype ?? "Default";

        // Update Elements
        function updateFeaturesElem() {
            const elem = document.getElementById("features")
            elem.clearChildren()

            for (const name of monster.features) {
                if (!database.features[name]) continue
                const feature = database.features[name]

                const { type, subtype, level, description } = feature
                const image = class_images[subtype] || feature_images[type] || ""

                collapsible({parent: elem,
                    options: {
                        button: {style: {display: "flex", gap: "1vh", padding: "0.5vh", margin: "0 1vh"}, events: {
                            mousedown: () => modal({parent: tab, children: [
                                data_description.feature({feature: feature})
                            ]})
                        }},
                        content: {style: {marginRight: "1.3vh", marginLeft: "1.3vh"}}
                    },
                    button_children: [
                        {tag: "img", attributes: {src: image}},
                        {tag: "span", text: name},
                        {tag: "span", style: {position: "absolute", right: "0.5vh"}, text: subtype || capitalize(type)}
                    ],
                })
            }

            // Hide Show feature block
            if (elem.children.length > 0) elem.parentElement.classList.remove("hidden")
            else elem.parentElement.classList.add("hidden")
        }
        function updateProficienciesElem() {
            const elem = document.getElementById("proficiencies")
            elem.clearChildren()

            for (const name in monster.proficiencies) {
                if (!database.proficiencies[name]) continue
                
                const level = monster.proficiencies[name]
                const proficiency = database.proficiencies[name]

                const type = proficiency?.type || "None"
                const description = proficiency?.description?.slice(0, level + 1) || ""
                const image = proficiency_images[type] || ""
                const level_title = [" Proficiency", " Expertise", " Mastery", " Grandmastery"][level]

                collapsible({parent: elem,
                    options: {
                        button: {style: {display: "flex", gap: "1vh", padding: "0.5vh", margin: "0 1vh"}, events: {
                            mousedown: () => modal({parent: tab, children: [
                                data_description.proficiency({proficiency: proficiency, level: level})
                            ]})
                        }},
                        content: {style: {marginRight: "1.3vh", marginLeft: "1.3vh"}}
                    },
                    button_children: [
                        {tag: "img", attributes: {src: image}},
                        {tag: "span", text: name + (type == "language" ? "" : level_title)},
                        {tag: "span", style: {position: "absolute", right: "0.5vh"}, text: capitalize(type)}
                    ],
                })
            }

            // Hide Show feature block
            if (elem.children.length > 0) elem.parentElement.classList.remove("hidden")
            else elem.parentElement.classList.add("hidden")
        }

        // Update attributes
        const updateAttribute = {input: function (event) {
            monster[this.id] = this.value
            //console.log(monster)
        }}
        const updateFeatures = {input: function (event) {
            const features = this.value
                .split(", ")
                .map(f => f.trim())
                .filter(f => f !== "");
            monster.features = [...new Set(features)];
            updateFeaturesElem()
            //console.log(monster)
        }}
        const updateProficiencies = {input: function (event) {
            const proficiencies = {};

            // Split into groups like "stealth:2"
            for (const prof_group of this.value.split(",")) {

                // Clean whitespace
                const cleaned = prof_group.trim();
                if (!cleaned) continue;  // skip empty groups

                const [proficiency_raw, level_raw] = cleaned.split(":");

                // Validate proficiency name
                const proficiency = proficiency_raw?.trim();
                if (!proficiency) continue;

                // Convert level to number (default 0)
                const level = Number(level_raw?.trim()) || 0;

                // Overwriting removes duplicates automatically
                proficiencies[proficiency] = level;
            }

            monster.proficiencies = proficiencies;
            updateProficienciesElem();
            //console.log(monster);
        }};

        // Content
        const containerOptions = {div: {attributes: {class: "hidden"}}, content: {style: {maxHeight: "20vh"}}}
        tab.appendChildren([
            {tag: "div", style: {position: "absolute", left: "0", width: "50%"}, children: [
                // Lore
                container({title: "Lore", children: [
                    // Name
                    input({id: "name", placeholder: "Name", options: {
                        input: {attributes: {value: monster.name || ""}, events: updateAttribute}
                    }}),

                    // Type
                    creatureTypeSelect,

                    // Race
                    input({id: "race", placeholder: "Race", options: {
                        div: {style: {width: "49%", marginRight: "1%"}},
                        input: {attributes: {value: monster.race || ""}, events: updateAttribute}
                    }}),

                    sizeSelect,

                    // Challenge Rating
                    input({id: "challenge_rating", placeholder: "Challenge Rating", options: {
                        div: {style: {width: "100%", marginRight: "0%"}},
                        input: {attributes: {value: monster.challenge_rating || ""}, events: updateAttribute}
                    }}),
                ]}),

                // Ability Scores
                container({title: "Ability Scores", children: abilityScores}),

                // Combat Stats
                container({title: "Stats", children: [
                    // Health Archetype
                    healthArchetypeSelect,

                    // Armor Class
                    input({id: "natural_armor_class", placeholder: "Natural Armor Class", options: {
                        div: {style: {width: "49%", marginRight: "0%"}},
                        input: {attributes: {value: monster.natural_armor_class ?? ""}, events: updateAttribute}
                    }}),

                    // Initiative Modifier
                    input({id: "initiative_mod", placeholder: "Initiative Modifier", options: {
                        div: {style: {width: "49%", marginRight: "2%"}},
                        input: {attributes: {value: monster.initiative_mod ?? ""}, events: updateAttribute}
                    }}),

                    // Speed
                    input({id: "speed", placeholder: "Speed", options: {
                        div: {style: {width: "49%", marginRight: "0%"}},
                        input: {attributes: {value: monster.speed || ""}, events: updateAttribute}
                    }}),
                ]}),

            ]},
            {tag : "div", style: {position: "absolute", right: 0, width: "50%"}, children: [
                container({title: "Special", children: [
                    // Features
                    input({placeholder: `Features (proficiency, proficiency)`, options: {
                        input: {attributes: {value: stringifyFeatures(monster.features)}, events: updateFeatures}
                    }}),

                    // Proficiencies
                    input({placeholder: `Proficiencies (proficiency:level, proficiency:level)`, options: {
                        input: {attributes: {value: stringifyProficiencies(monster.proficiencies)}, events: updateProficiencies}
                    }}),
                ]}),

                container({id: "features", scroll: true, title: "Features", options: containerOptions}),
                container({id: "proficiencies", scroll: true, title: "Proficiencies", options: containerOptions})
            ]},
            {tag: "button", text: "Submit", attributes: {class: "bottom right page-turner"}, 
                events: {click: submit}
            },
            {tag: "button", text: "Cancel", attributes: {class: "bottom left page-turner"}, 
                events: {click: cancel}
            }
        ])
    }

    async function spellcastingTab () {
        const tab = document.getElementById("spellcasting-tab")
        const database = JSON.parse(await backend(`JSON.stringify({
            spells: database.spells.data,
            spells_list: database.get_spells_list()
        })`))
        const spellcasting_class = "Monster"

        // Update Attributes
        const updateSpellcastingLevel = {input: function (event) {
            monster.spellcasting_level = Number(this.value) || 0
            //console.log(monster)
        }}
        const updateKnown = {input: function (event) {
            const spells = this.value
                .split(", ")
                .map(f => f.trim())
                .filter(f => f !== "");
            monster.spells[spellcasting_class].known = [...new Set(spells)];
            updateSpellsElem()
            //console.log(monster)
        }}
        const updateInnate = {input: function (event) {
            const spells = this.value
                .split(", ")
                .map(f => f.trim())
                .filter(f => f !== "");
            monster.spells[spellcasting_class].innate = [...new Set(spells)];
            updateSpellsElem()
            //console.log(monster)
        }}

        // Update Elements
        function updateSpellsElem() {
            const elem = document.getElementById("spells")
            elem.clearChildren()

            // Spell List
            const class_spells = monster.spells?.[spellcasting_class] || {}
            const selected_spells = [
                ...(class_spells?.known || []),
                ...(class_spells?.innate || [])
            ]
            const ordered_spells = database.spells_list.filter(spell => selected_spells.includes(spell))

            let previous_level = undefined
            for (const name of ordered_spells) {
                const spell = database.spells[name]
                const spell_image = spell.image || spell_school_images[spell.school]

                // Conditions
                const spellIsMemorized = class_spells.memorized?.includes(spell.name)
                const spellIsAlwaysPrepared = class_spells.always_prepared?.includes(spell.name)
                const spellIsInnate = class_spells.innate?.includes(spell.name)
                const spellIsCantrip = spell.level == "cantrip"
                
                // Action type
                let action_type
                if (spell.cast_time == -1) action_type = "Bonus Action"
                else if (spell.cast_time == -2) action_type = "Reaction"
                else if (spell.cast_time >= 0) action_type =  "Action"

                // Accent Color
                let accentColor = ""
                if (spellIsInnate) accentColor = "#ca2"
                else if (spellIsAlwaysPrepared) accentColor = "#aaa"

                // Click Spell
                function clickSpell (event) {
                    modal({parent: tab, children: [
                        data_description.spell({spell: spell})
                    ]})
                }

                // Add spacing between levels
                if (previous_level != spell.level) {
                    elem.appendChild({tag: "div", style: {margin: "1.3vh", marginTop: "2vh", padding: 0, fontWeight: "bold"}, text: spell.level == "cantrip" ? "Cantrips" : spell.level + " Level Spells"})
                    previous_level = spell.level
                }

                // Add element
                elem.appendChild(
                    {tag: "div", 
                        attributes: {class: "collapsible-div"}, 
                        style: {
                            display: "flex", gap: "1vh", padding: "0.5vh", marginTop: "1vh",
                            borderColor: accentColor,
                            opacity: 1
                        },
                        events: {mousedown: clickSpell},
                        children: [
                            {tag: "img", attributes: {src: spell_image}},
                            {tag: "span", text: name},
                            {tag: "span", style: {position: "absolute", right: "0.5vh"}, text: action_type},
                        ]
                    }
                )
            }
            
            // Hide Show block
            if (elem.children.length > 0) elem.parentElement.classList.remove("hidden")
            else elem.parentElement.classList.add("hidden")
        }

        // Content
        const containerOptions = {div: {attributes: {class: "hidden"}}, content: {style: {maxHeight: "80vh"}}}
        tab.appendChildren([
            {tag: "div", style: {position: "absolute", left: "0", width: "50%"}, children: [
                // Details
                container({title: "Details", children: [
                    // Spellcasting Level
                    input({id: "spellcasting_level", placeholder: "Spellcasting Level", options: {
                        input: {attributes: {value: monster.spellcasting_level || ""}, events: updateSpellcastingLevel}
                    }}),
                ]}),

                // Spell List
                container({title: "Spell List", children: [
                    // Known Spells
                    input({id: "known", placeholder: "Known Spells", options: {
                        input: {attributes: {value: stringifyKnownSpells(monster, spellcasting_class) || ""}, events: updateKnown}
                    }}),

                    // Innate Spells
                    input({id: "innate", placeholder: "Innate Spells", options: {
                        input: {attributes: {value: stringifyInnateSpells(monster, spellcasting_class) || ""}, events: updateInnate}
                    }}),
                ]})
            ]},
            {tag : "div", style: {position: "absolute", right: 0, width: "50%"}, children: [
                container({id: "spells", scroll: true, title: "Spells", options: containerOptions}),
            ]},
            {tag: "button", text: "Submit", attributes: {class: "bottom right page-turner"}, 
                events: {click: submit}
            },
            {tag: "button", text: "Cancel", attributes: {class: "bottom left page-turner"}, 
                events: {click: cancel}
            }
        ])
    }

    async function abilitiesTab() {
        const tab = document.getElementById("abilities-tab")
        let ability_name = ""
        const ability = {
            description: "",
            type: "Attack", // Attack or Special
            origin: "Monster",
            resources: [],
            damage: [],
            difficulty_class: 10,
            save_attribute: "strength",
            conditions: [],
            range: 5,
            max_targets: 1,

            // Attack type
            recovery: 0,
            hit_bonus: 2,

            // Special type
            cast_time: 0,
            half_damage_on_save: false,
        }

        // Updates
        const updateType = {input: function (event) {
            ability.type = this.value
            const attackElements = ["hit-bonus", "recovery"]
            const specialElements = ["half-damage-on-save", "cast-time"]

            switch(this.value) {
                case "Attack": {
                    for (const element of specialElements) document.getElementById("ability-" + element + "-div").style.display = "none"
                    for (const element of attackElements) document.getElementById("ability-" + element + "-div").style.display = ""
                    break
                }
                case "Special": {
                    for (const element of specialElements) document.getElementById("ability-" + element + "-div").style.display = ""
                    for (const element of attackElements) document.getElementById("ability-" + element + "-div").style.display = "none"
                    break
                }
                default: {
                    for (const element of [...attackElements, ...specialElements]) document.getElementById("ability-" + element + "-div").style.display = "none"
                    break
                }
            }
        }}
        const updateResources = {input: function (event) {
            const resources = this.value
                .split(", ")
                .map(f => f.trim())
                .filter(f => f !== "");
            ability.resources = [...new Set(resources)];
        }}
        const updateDamage = {input: function (event) {
            const damage = [];

            // Example input:
            // "1d4 Piercing, 2d6+3 Fire, 3d8-1 Cold"
            const entries = this.value.split(",").map(s => s.trim());

            for (const entry of entries) {
                if (!entry) continue;

                // Split into first part (dice block) and the rest (damage type)
                // Example: "2d6+3 Fire" → ["2d6+3", "Fire"]
                const parts = entry.split(" ");
                if (parts.length < 2) continue;

                const dice_block = parts[0];          // "2d6+3"
                const damage_type = parts.slice(1).join(" "); // "Fire"

                // Find where the dice end and bonus begins
                // Allowed formats:
                // XdY
                // XdY+Z
                // XdY-Z

                let die_amount = "";
                let die_size = "";
                let damage_bonus = "";

                // STEP 1 — Split by "d"
                const d_index = dice_block.indexOf("d");
                if (d_index === -1) continue;

                die_amount = dice_block.substring(0, d_index);
                let after_d = dice_block.substring(d_index + 1);

                // STEP 2 — Detect + or -
                let plus_index = after_d.indexOf("+");
                let minus_index = after_d.indexOf("-");

                if (plus_index !== -1) {
                    // format 2d6+3
                    die_size = after_d.substring(0, plus_index);
                    damage_bonus = after_d.substring(plus_index + 1);
                }
                else if (minus_index !== -1) {
                    // format 3d8-1
                    die_size = after_d.substring(0, minus_index);
                    damage_bonus = "-" + after_d.substring(minus_index + 1);
                }
                else {
                    // format only XdY
                    die_size = after_d;
                }

                // put it together
                const dmg_obj = {
                    damage_type,
                    die_amount,
                    die_size
                };

                if (damage_bonus !== "") {
                    dmg_obj.damage_bonus = damage_bonus;
                }

                damage.push(dmg_obj);
            }

            ability.damage = damage;
        }};
        const updateConditions = {input: function (event) {
            const conditions = [];

            // Split by comma → ["Prone:-1", "Ray of Frost: 1"]
            const entries = this.value.split(",").map(s => s.trim());

            for (const entry of entries) {
                if (!entry) continue;

                // Split by ":" → ["Prone", "-1"] or ["Ray of Frost", "1"]
                const parts = entry.split(":").map(s => s.trim());
                if (parts.length !== 2) continue;

                const name = parts[0];
                const duration_string = parts[1];

                // Convert duration to number (fallback if invalid)
                const duration = parseInt(duration_string, 10);
                if (isNaN(duration)) continue;

                conditions.push({
                    name,
                    duration
                });
            }

            ability.conditions = conditions;
        }};
        const updateSaveAttribute = {input: function (event) {
            ability.save_attribute = this.value.toLowerCase()
        }}

        // Update Elements
        function updateForm() {
            var get = function (id) { return document.getElementById(id); };

            // Name
            get("ability-name").value = ability.name || "";

            // Type
            get("ability-type").value = ability.type;
            get("ability-type").dispatchEvent(new Event("change"))

            // Resources
            get("ability-resources").value = (ability.resources || []).join(", ");

            // Hit bonus
            get("ability-hit-bonus").value = ability.hit_bonus != null ? ability.hit_bonus : "";

            // Recovery
            get("ability-recovery").value = ability.recovery != null ? ability.recovery : "";

            // Half damage on save
            get("ability-half-damage-on-save").value = ability.half_damage_on_save ? "True" : "False";
            get("ability-half-damage-on-save").dispatchEvent(new Event("change"))

            // Cast time
            get("ability-cast-time").value = ability.cast_time != null ? ability.cast_time : "";

            // Damage stringification
            get("ability-damage").value = (ability.damage || [])
                .map(function (d) {
                    var bonus = "";
                    if (d.damage_bonus) {
                        if (d.damage_bonus.indexOf("-") === 0) bonus = d.damage_bonus;
                        else bonus = "+" + d.damage_bonus;
                    }
                    return d.die_amount + "d" + d.die_size + bonus + " " + d.damage_type;
                })
                .join(", ");

            // Difficulty class
            get("ability-difficulty-class").value =
                ability.difficulty_class != null ? ability.difficulty_class : "";

            // Save attribute
            get("ability-save-attribute").value =
                ability.save_attribute
                    ? ability.save_attribute.charAt(0).toUpperCase() + ability.save_attribute.slice(1)
                    : "Strength";
            get("ability-save-attribute").dispatchEvent(new Event("change"))

            // Conditions
            get("ability-conditions").value = (ability.conditions || [])
                .map(function (c) {
                    return c.name + ":" + c.duration;
                })
                .join(", ");

            // Range
            get("ability-range").value = ability.range != null ? ability.range : "";

            // Max targets
            get("ability-max-targets").value =
                ability.max_targets != null ? ability.max_targets : "";
        }

        function updateAbilitiesElem() {
            const elem = document.getElementById("actions")
            elem.clearChildren()

            for (const name in monster.abilities) {
                const cur_ability = monster.abilities[name]
                cur_ability.name = name

                // Remove
                function remove () {
                    delete monster.abilities[name]
                    updateAbilitiesElem()
                }

                // Edit
                function edit () {
                    for (const key in cur_ability) ability[key] = cur_ability[key]
                    updateForm()
                }

                // Mousedown
                async function mousedown (event) {
                    // Left Click
                    if (event.button == 0) {
                        modal({parent: tab, children: [
                            await data_description.monster_ability({object: cur_ability})
                        ]})
                    }
                    // Right click
                    else if (event.button == 2) {
                        // Buttons
                        const buttons = {
                            "Edit": edit,
                            "Remove": remove,
                        }

                        // Run context menu
                        context_menu({event: event, buttons: buttons})
                    }
                }

                // Add element
                elem.appendChild(
                    {tag: "div", 
                        attributes: {class: "collapsible-div"}, 
                        style: {
                            display: "flex", gap: "1vh", padding: "0.5vh", marginTop: "1vh",
                            opacity: 1
                        },
                        events: {mousedown: mousedown},
                        children: [
                            {tag: "img", attributes: {src: ""}},
                            {tag: "span", text: name},
                            {tag: "span", style: {position: "absolute", right: "0.5vh"}, text: ability.type},
                        ]
                    }
                )
            }
            
            // Hide Show block
            if (elem.children.length > 0) elem.parentElement.classList.remove("hidden")
            else elem.parentElement.classList.add("hidden")
        }

        // Set
        const set = {click: function (event) {
            if (ability_name) monster.abilities[ability_name] = ability
            console.log(monster.abilities)
            updateAbilitiesElem()
        }}

        // Content
        const containerOptions = {div: {attributes: {class: "hidden"}}, content: {style: {maxHeight: "80vh"}}}
        tab.appendChildren([
            {tag: "div", style: {position: "absolute", left: "0", width: "50%"}, children: [
                container({title: "Action Details", children: [
                    // Name
                    input({id: "ability-name", placeholder: "Name", options: {
                        input: {attributes: {value: ""}, events: {input: function (event) {ability_name = this.value}}}
                    }}),

                    // Type
                    select({id: "ability-type", placeholder: "Type", 
                        children: ["Attack", "Special"].map((item) => ({tag: "option", text: item})),
                        options: {
                            input: {events: updateType}
                        }
                    }),

                    // Resources
                    input({id: "ability-resources", placeholder: "Resources", options: {
                        input: {attributes: {value: ""}, events: updateResources}
                    }}),

                    // Hit Bonus
                    input({id: "ability-hit-bonus", placeholder: "Hit Bonus", options: {
                        input: {attributes: {value: ""}, events: {input: function (event) {ability.hit_bonus = Number(this.value) || 0}}}
                    }}),

                    // Recovery
                    input({id: "ability-recovery", placeholder: "Recovery", options: {
                        input: {attributes: {value: ""}, events: {input: function (event) {ability.recovery = Number(this.value) || 0}}}
                    }}),

                    // Half Damage on Save
                    select({
                        id: "ability-half-damage-on-save",
                        placeholder: "Half Damage on Save",
                        children: [
                            { tag: "option", text: "False" },
                            { tag: "option", text: "True" }
                        ],
                        options: {
                            input: {
                                events: {
                                    input: function (event) {
                                        ability.half_damage_on_save = this.value === "True";
                                    }
                                }
                            }
                        }
                    }),


                    // Cast Time
                    input({id: "ability-cast-time", placeholder: "Cast Time", options: {
                        input: {attributes: {value: ""}, events: {input: function (event) {ability.cast_time = Number(this.value) || 0}}}
                    }}),
                    
                    // Damage
                    input({id: "ability-damage", placeholder: "Damage (1d4+2 Bludgeoning, 1d4 Fire)", options: {
                        input: {attributes: {value: ""}, events: updateDamage}
                    }}),

                    // Difficulty Class
                    input({id: "ability-difficulty-class", placeholder: "Difficulty Class", options: {
                        div: {style:{width: "49%", marginRight: "2%"}},
                        input: {attributes: {value: ""}, events: {input: function (event) {ability.difficulty_class = Number(this.value) || 0}}}
                    }}),

                    // Save Attribute
                    select({id: "ability-save-attribute", placeholder: "DC Attribute", 
                        children: ["Strength", "Dexterity", "Constitution", "Wisdom", "Intelligence", "Charisma"].map((item) => ({tag: "option", text: item})),
                        options: {
                            div: {style:{width: "49%"}},
                            input: {events: updateSaveAttribute}
                        }
                    }),

                    // Conditions
                    input({id: "ability-conditions", placeholder: "Conditions (Paralyzed:1, Prone:-1)", options: {
                        input: {attributes: {value: ""}, events: updateConditions}
                    }}),

                    // Range
                    input({id: "ability-range", placeholder: "Range", options: {
                        input: {attributes: {value: ""}, events: {input: function (event) {ability.range = Number(this.value) || 5}}}
                    }}),

                    // Max Targets
                    input({id: "ability-max-targets", placeholder: "Max Targets", options: {
                        input: {attributes: {value: ""}, events: {input: function (event) {ability.max_targets = Number(this.value) || 1}}}
                    }}),
                
                    // Save
                    {tag: "button", text: "Save", events: set, style: {marginTop: "2vh"}}
                ]}),
            ]},
            {tag : "div", style: {position: "absolute", right: 0, width: "50%"}, children: [
                container({id: "actions", scroll: true, title: "Actions", options: containerOptions}),
            ]},
            {tag: "button", text: "Submit", attributes: {class: "bottom right page-turner"}, 
                events: {click: submit}
            },
            {tag: "button", text: "Cancel", attributes: {class: "bottom left page-turner"}, 
                events: {click: cancel}
            }
        ])

        updateAbilitiesElem()
    }

    async function loadPage() {
        create_tabs({content: ["main", "spellcasting", "abilities"], parent: document.body})
        await loadMonster()

        await mainTab()
        await spellcastingTab()
        await abilitiesTab()

        triggerAllInputFields()
    }
    
    //=====================================================================================================
    // Execution
    //=====================================================================================================

    window.onload = function () {
        loadPage()
    }

    //=====================================================================================================

    </script>
    ']
</head>

<body>
</body>

}]